<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#fff"><link rel="preload" href="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/fonts/Candyshop.otf" as="font" type="font/otf" crossorigin="anonymous"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.74" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=0.0.74"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.ico?v=0.0.74"><link rel="mask-icon" href="/safari-pinned-tab.svg?v=0.0.74" color="#fff"><link rel="manifest" href="/manifest.json"><meta name="keywords" content="いざよい,everbrez"><link rel="alternate" href="/atom.xml" title="Hi, いざよい" type="application/atom+xml"><meta name="description" content="If I could be the hero"><meta property="og:type" content="website"><meta property="og:title" content="Hi, いざよい"><meta property="og:url" content="https://everbrez.github.io/page/5/index.html"><meta property="og:site_name" content="Hi, いざよい"><meta property="og:description" content="If I could be the hero"><meta property="og:locale"><meta property="article:author" content="everbrez"><meta property="article:tag" content="いざよい,everbrez"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"",scheme:"Pisces",version:"0.0.74",sidebar:{position:"right",display:"always",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"4/18/2021 18:00:00",site:{title:"",subtitle:"",author:""},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!1,appID:"",appKey:""},favicon:{visibilitychange:!0,narmal:"/assets/favicon.ico",hidden:"/assets/favicon.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/disqusjs@1.2.2/dist/disqus.js"></script><link rel="canonical" href="https://everbrez.github.io/page/5/"><title>Hi, いざよい</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" class="theme-darling"><div class="container sidebar-position-right page-home"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fas fa-meteor"></i><br>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fas fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="menu-item-icon fas fa-heartbeat"></i><br>关于我</a></li><li class="menu-item search"><form class="search-form"><input name="keyword" type="text" class="search-input" placeholder="站内搜索"> <button type="submit" class="search-submit"><i class="fas fa-search"></i></button></form></li></ul></nav><div class="site-brand-wrapper"><div class="site-brand-bg"><picture><source srcset="/assets/images/mainvisual2.jpeg" type="image/webp"><img style="transform:translateY(-300px)" loading="lazy" src="/assets/images/mainvisual2.jpeg"></picture></div><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate-stroke" class="animate"><span><svg><use xlink:href="#strokeH"></use></svg> </span><span><svg><use xlink:href="#strokei"></use></svg> </span><span><svg><use xlink:href="#stroke,"></use></svg> </span><span><svg><use xlink:href="#stroke "></use></svg> </span><span><svg><use xlink:href="#strokeい"></use></svg> </span><span><svg><use xlink:href="#strokeざ"></use></svg> </span><span><svg><use xlink:href="#strokeよ"></use></svg> </span><span><svg><use xlink:href="#strokeい"></use></svg></span></div><div id="animate" class="animate"><span><svg><text id="strokeH">H</text></svg> </span><span><svg><text id="strokei">i</text></svg> </span><span><svg><text id="stroke,">,</text></svg> </span><span><svg><text id="stroke "></text></svg> </span><span><svg><text id="strokeい">い</text></svg> </span><span><svg><text id="strokeざ">ざ</text></svg> </span><span><svg><text id="strokeよ">よ</text></svg> </span><span><svg><text id="strokeい">い</text></svg></span></div><div id="guide" class="guide"><span>H</span><span>i</span><span>,</span><span> </span><span>い</span><span>ざ</span><span>よ</span><span>い</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/assets/images/avatar.webp" type="image/webp"><img loading="lazy" class="site-master-avatar scaleup" itemprop="image" src="/assets/images/avatar.jpg" alt=""></picture><h2 class="site-master-description scaleup" itemprop="description">If I could be the hero</h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/security/" itemprop="url" rel="index"><span itemprop="name">security</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-web-security/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-web-security/" itemprop="url">web security</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">2120</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><p><code>XSS（cross site scripting</code>），跨站脚本攻击 ，是一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，使之可以在用户浏览器上运行。攻击者可以获取用户的敏感信息如<code>cookie</code>、<code>sessionID</code>等，进而危害数据安全。</p><p>本质：恶意代码没有过滤，与网站正常代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。（HTML注入）</p><p>在处理输入的时候，以下内容都不可信：</p><ul><li>来自用户的UGC信息</li><li>来自第三方的连接</li><li>URL参数</li><li>POST参数</li><li>Referer</li><li>Cookie</li></ul><p>XSS攻击分为两种类型：</p><ol><li>存储型，恶意代码存在于数据库</li><li>反射性，恶意代码存在于URL中</li><li>DOM型，恶意代码存在于URL或者输入框，前端JavaScript取出执行，属于前端JavaScript的安全漏洞（关闭属性或者关闭标签）</li></ol><h2 id="XSS注入的方法："><a href="#XSS注入的方法：" class="headerlink" title="XSS注入的方法："></a>XSS注入的方法：</h2><ol><li>HTML中内嵌文本，恶意内容以script标签形成注入</li><li>内联JavaScript中，拼接的数据突破了原本的限制</li><li>标签属性中，恶意内容突破属性值的限制，注入其他属性的标签</li><li>在标签的<code>href</code>、<code>src</code>属性中，包含JavaScript：等可执行代码</li><li>在<code>onload</code>、<code>onerror</code>、<code>onclick</code>等事件中，注入不受控制代码</li><li>在<code>style</code>属性和标签中，包含类似url(<code>JavaScript:</code>)的代码，新版浏览器已经可以防范</li><li>在<code>style</code>属性和标签中，包含类似<code>expression()</code>的CSS表达式代码，新版浏览器已经可以防范</li></ol><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><ol><li>输入检查，查找敏感信息<ol><li>前端过滤：攻击者可以伪造请求</li><li>后端在写在数据库前过滤：不确定内容要输出到哪里。（在前端中，不同位置所需要的编码不同，如html与JavaScript）</li><li>对于明确的过滤类型：如电话，邮箱等提前过滤</li></ol></li><li>预防存储行和反射性XSS攻击，输出检查<ol><li>对HTML对充分的转义，利用成熟的转义库，利用模板引擎</li><li>避免内联事件</li><li>改成纯前端渲染，把代码和数据分隔开（JavaScript来调用Ajax来渲染的数据）</li><li>在HTML中输出，在CSS中输出，在JavaScript中输出，在URL等属性中输出，在内联属性中输出。<ol><li>其中URL中有可能是其他协议的（伪协议）</li></ol></li><li>处理富文本：使用白名单</li></ol></li><li>预防DOM型XSS攻击，使用<code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code>的时候小心，不要把不可信的数据作为HTML插到页面上，a标签的<code>href</code>属性，JavaScript中的eval、setTimeout、setIntercal都能够将字符串当成代码运行。</li><li>CSP</li><li>Cookie: HTTP only</li><li>验证码</li><li>不信任的输入限定长度（增强攻击难度）</li><li>www-x-frame2</li></ol><h2 id="XSS构造技巧"><a href="#XSS构造技巧" class="headerlink" title="XSS构造技巧"></a>XSS构造技巧</h2><ul><li>利用location.hash，然后构造onload事件，绕过length限制</li><li>利用base标签劫持链接</li><li>window.name利用</li><li>flash，</li></ul><h2 id="持久型"><a href="#持久型" class="headerlink" title="持久型"></a>持久型</h2><p>持久型就是攻击的代码被服务端写进了数据库，这种攻击危害性很大</p><h2 id="非持久型"><a href="#非持久型" class="headerlink" title="非持久型"></a>非持久型</h2><p>非持久型一般通过修改URL参数的方式加入攻击代码，诱导用访问链接从而进行攻击</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><ul><li>对引号、尖括号、斜杠等进行转义</li><li>采用白名单过滤</li></ul><h2 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h2><p>CSP本质上就是建立白名单，明确告诉浏览器哪些外部资源可以加载和执行<br>通过以下两种方式来开启CSP</p><ol><li>设置HTTP Header中的 <code>Content-Security-Policy</code></li><li>设置标签<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ol><p>作用：</p><ol><li>禁止加载外域代码，防止复杂的攻击逻辑</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域</li><li>禁止内联脚本执行</li><li>禁止未授权脚本执行（未授权）</li><li>合理使用上报可以即使发现XSS</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jaVasCript:<span class="comment">/*-/*`/*\`/*&#x27;/*&quot;/**/</span>(<span class="comment">/* */</span>oNcliCk=alert() )<span class="comment">//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span></span><br></pre></td></tr></table></figure><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>Cross-site Request Forgery 跨站请求伪造<br>Cookie分为两种：<br>Third-party Cookie：只有过了expire时间后失效<br>Session Cookie：临时Cookie，连接断开就失效了</p><p>本质：重要操作的所有参数都是可以被攻击者猜测到的。</p><p>防御：</p><ol><li>Get请求不对数据进行修改</li><li>不让第三方网站访问到用户cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，验证码或者Token，这个是最有效的方式</li><li>Referer Check（但是浏览器会限制referer的发送。比如https跳到http）<ol><li>H5中a和area标签可以设置一个新的link types：noreferrer，即不再发送referrer（用户隐私）</li></ol></li><li>将参数加密，或者使用一些随机数，让攻击者无法猜测到。</li></ol><p>Cookie设置 <code>sameSite</code>属性，cookie不随着跨域请求发送</p><p>验证Referer：验证Referer判断是否为第三方网站发起的请求</p><p>Token：服务器随机生成一个Token，每次请求的时候将Token带上，服务器验证是否有效<br>多页面共存情况，保密性</p><h1 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h1><p>点击劫持是一种视觉欺骗手段，攻击者将需要攻击的网站通过iframe嵌套的方式嵌入自己的网页中，并将iframe设置为透明，在页面中透出一个按钮诱导用户点击</p><p>由于手机上的浏览器隐藏了地址栏，所以手机上的点击劫持更容易实现</p><p>防御：</p><ol><li>设置X-FRAME-OPTION，为了防御<code>iframe</code>嵌套的点击劫持攻击</li></ol><p>有三个值可选：</p><ul><li>DENY，表示页面不允许通过<code>iframe</code>方式展示</li><li>SAMEORIGIN 表示页面可以在相同域名下通过<code>iframe</code>的方式展示</li><li>ALLOW-FROM，表示页面可以在指定来源的<code>iframe</code>中展示</li></ul><ol start="2"><li>通过js代码检查自己网页是否为<code>top</code></li></ol><p>H5中为<code>iframe</code>添加了sandbox功能，能够通过参数来支持更精确的控制：</p><ul><li>allow-same-origin 允许同源访问</li><li>allow-top-navigation 允许访问顶层窗口</li><li>allow-forms 允许提交表单</li><li>allow-scripts 允许执行脚本</li></ul><h1 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h1><p>中间人攻击时攻击方同时与服务端和客户端建立起连接，并让对方认为连接是安全的。但实际上整个通信过程都被攻击者控制了，攻击者不仅能够狗获得双方的通信信息，还能修改通信信息</p><p>防御：</p><ol><li>HTTPS可以防御中间人攻击</li></ol><h1 id="DDoS-分布式拒绝服务"><a href="#DDoS-分布式拒绝服务" class="headerlink" title="DDoS 分布式拒绝服务"></a>DDoS 分布式拒绝服务</h1><p>Distribute Denied of Server<br>在短时间内发起大量请求，耗尽服务器的资源，无法相应正常的访问，造成网站实质下线。</p><ul><li>TCP全连接攻击：通过大量僵尸主机不断与服务器建立大量TCP服务，耗尽服务器资源。<ul><li>优点：能够绕过防火墙，缺点：需要找到大量的僵尸主机，如果僵尸主机的IP暴露容易被驱逐</li><li>防御：限制SYN流量，定期扫描，骨干节点配置防火墙，用足够的机器承受住黑客的攻击，过滤不必要的服务和端口（在路由器上过滤假IP）</li></ul></li><li>SYN Flood 攻击<ul><li>发送大量伪造原IP地址的攻击报文，而真实IP不作回应</li><li>服务端在重试和等待SYN Timeout的过程中维持着一个非常大的半连接队列而消耗大量的CPU和内存</li><li>解决：使用硬件防火墙（由防火墙代理该连接，验证有效后才向内部服务器发起SYN请求，最后才建立连接。防火墙要对序列的序列号进行修改），硬件防火墙是指将防火墙程序做到芯片里面，由硬件执行里面的功能，能够减少CPU的负担，使路由更稳定。</li><li>使用SYN Cache技术。收到SYN的时候不急着去分配系统资源，先回应ACK报文，并在专用的HASH表中保存这种半连接报文，直到收到正确的ACK后再分配资源。</li></ul></li></ul><h1 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h1><p>这种攻击方式采用了特别构造的TCP SYN数据包（通常用于开启一个新的连接），使目标机器开启一个源地址与目标地址均为自身IP地址的空连接，持续地自我应答，消耗系统资源直至崩溃。</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-web-security/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-webpack-optimize/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-webpack-optimize/" itemprop="url">webpack optimize</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">462</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="Webpck-性能优化"><a href="#Webpck-性能优化" class="headerlink" title="Webpck 性能优化"></a>Webpck 性能优化</h1><h2 id="减少Webpack打包时间"><a href="#减少Webpack打包时间" class="headerlink" title="减少Webpack打包时间"></a>减少Webpack打包时间</h2><ol><li>优化<code>loader</code><br>对于<code>Babel</code>，<code>Babel</code>会将代码从字符串转化成<code>AST</code>，然后从AST再转化成新的代码。所以项目越大，转换代码越多，效率就越低。<ul><li>优化文件搜索范围（可以不用编译<code>node_modules</code>）中的代码，因为里面的代码都是编译过的。</li><li>可以设置缓存，将<code>Babel</code>编译过的代码缓存起来，下次只需要编译更改过的代码即可。</li></ul></li><li>使用<code>HappyPack</code><br>由于Node是单线程运行的，所以<code>webpack</code>在打包的过程中也是单线程的，特别是在执行<code>loader</code>的时候，长时间编译的任务很多，这样就会导致等待的情况。<br><code>HappyPack</code>可以将<code>loader</code>从同步执行转换成并行的。充分利用系统资源加快打包效率</li><li><code>DllPlugin</code><br><code>DllPlugin</code>可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数。主要当类库更新版本才有需要重新打包</li><li>代码压缩<br>在<code>webpack4</code>中，只要将<code>mode</code>设置为<code>production</code>就可以默认开启代码压缩功能（还可以配置删除<code>console</code>类代码）</li><li><code>resolve.extensions</code>，尽可能减少后缀列表长度，将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：设置别名的方式映射一个路径，让Webpack更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，可以让<code>webpack</code>不扫描该文件。</li></ol><h3 id="减少Webpack打包体积"><a href="#减少Webpack打包体积" class="headerlink" title="减少Webpack打包体积"></a>减少Webpack打包体积</h3><ol><li>按需加载，为每一个路由页面单独打包成一个文件</li><li><code>Scope Hoisting</code>，代码合并到一个函数。<br>webpack4可以设置<code>optimization.concatenateModules</code></li><li><code>TreeShaking</code> 可以删除项目中未被引用的代码<br>Webpack4自动启动这个优化功能</li></ol><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-webpack-optimize/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-webpack-principle/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-webpack-principle/" itemprop="url">webpack principle</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">93</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><ol><li>使用Babel转换代码，分析文件中的dependencies，转换代码code，返回对象。（parseCode）</li><li>利用parseCode处理入口文件，然后根据dependencies中的依赖，寻找出所有依赖之后返回一个依赖数组（处理依赖的时候处理依赖的路径）</li><li>打包功能：将文件利用CommonJS的语法进行打包</li></ol><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-webpack-principle/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-18-algorithm-fundamental/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-18-algorithm-fundamental/" itemprop="url">algorithm fundamental</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">190</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>十进制转二进制：<br>如33：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span> / <span class="number">2</span> = <span class="number">16</span> + <span class="number">1</span></span><br><span class="line"><span class="number">16</span> / <span class="number">2</span> = <span class="number">8</span> + <span class="number">0</span></span><br><span class="line"><span class="number">8</span> / <span class="number">2</span> = <span class="number">4</span> + <span class="number">0</span></span><br><span class="line"><span class="number">4</span> / <span class="number">2</span> = <span class="number">2</span> + <span class="number">0</span></span><br><span class="line"><span class="number">2</span> / <span class="number">2</span> = <span class="number">1</span> + <span class="number">0</span></span><br><span class="line"><span class="number">1</span> / <span class="number">2</span> = <span class="number">0</span> + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以二进制为：<code>100001</code>（按照从下到上的顺序）</p><p>小数转二进制<br>如0.1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0</span> + <span class="number">0.2</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0</span> + <span class="number">0.4</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0</span> + <span class="number">0.8</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1</span> + <span class="number">0.6</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1</span> + <span class="number">0.2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以二进制为<code>0.0(0011)</code>（按照从上到下的顺序）</p><h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 <code>&lt;&lt;</code></h2><p>可以看成 <code>a * (2 ** b)</code></p><h2 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 <code>&gt;&gt;</code></h2><p>可以看成 <code>a / (2 ** b)</code></p><blockquote><p>右移可以在二分法中取中间值</p></blockquote><h2 id="按位与-amp"><a href="#按位与-amp" class="headerlink" title="按位与 &amp;"></a>按位与 <code>&amp;</code></h2><p><code>8 &amp; 7 =&gt; 0</code></p><h2 id="按位或"><a href="#按位或" class="headerlink" title="按位或 |"></a>按位或 <code>|</code></h2><p><code>8 | 7 =&gt; 15</code></p><h2 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或 ^"></a>按位异或 <code>^</code></h2><p>每一位不同才会为<code>1</code></p><p>两个数不通过四则运算得出和：</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-18-algorithm-fundamental/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-18-design-pattern/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-18-design-pattern/" itemprop="url">design pattern</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1412</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式的核心是确保只有一个实例，并提供全局访问，减少了内存开支（在频繁需要创建和销毁时）<br>惰性单例<br>创建对象的职责和管理单例的职责可以分布在两个不同的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSingle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">new</span>.target) instance = <span class="keyword">new</span> fn()</span><br><span class="line">      <span class="keyword">else</span> instance = fn.apply(<span class="built_in">this</span>, fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法不能保证instanceof 能够正常工作</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就很有用。<br>尽量减少共享对象的数量。<br>使用享元模式的关键是怎样区分内部状态和外部状态。可以被对象共享的状态通常被划分为内部状态</p><p>对象池的实现</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>定义一系列的算法，把他们一个个封装起来。（在JavaScript中可以直接作为一个对象的方法）<br>应用场景：缓动动画、表单校验<br>方便后期的扩展和更改</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器使原来接口不兼容的两个软件实体可以正常工作<br>装饰者的作用是给对象增加功能，而适配器是解决两个接口不兼容的问题</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是为对象提供一个代用品和占位符，以便控制对它的访问<br>代理可以帮助target过滤一些请求（这种代理叫做保护代理），虚拟代理则是把一些开销很大的对象延迟到真正需要它的时候采取创建。缓存代理，惰性加载</p><p>代理和本体接口的一致性：代理和本体可以替换使用，这意味着当不需要代理功能的时候，可以直接访问本体。</p><p>单一职责，一个类而言，应该仅有一个引起它变化的原因。</p><p>应用：虚拟代理图片预加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> Image</span><br><span class="line">  img.src = <span class="string">&#x27;loading.gif&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.body.append(img)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setSrc</span>(<span class="params">src</span>)</span> &#123;</span><br><span class="line">      img.src = src</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myImage = createImg()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxy</span>(<span class="params">img</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">setSrc</span>(<span class="params">src</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> image = <span class="keyword">new</span> Image</span><br><span class="line">      image.src = src</span><br><span class="line">      image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;img.setSrc(src)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myImageProxy = createProxy(myImage)</span><br></pre></td></tr></table></figure><h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>发布订阅模式又称观察者模式，定义了对象当中的一对多的关系。<br>解耦，（网站登陆的例子），全局Event对象（如同中介），（先订阅再发布？）</p><p>弱化对象之间的联系，解耦时间和空间，消耗时间和空间</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。<br>将对象封装成命令对象，提供execute方法</p><ul><li>撤销和重做</li><li>宏命令（命令模式和组合模式）</li></ul><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>可以解耦大量的if/else模式，解耦了请求发送者和N个接收者之间的复杂关系（比如订单问题）</p><p>需要在链尾添加一个保底的接收者节点来处理这种即将离开链尾的请求。</p><p>AOP实现职责链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fn = fn</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">after</span>(<span class="params">next</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">passRequest</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">this</span>.fn(...args)</span><br><span class="line">    <span class="keyword">if</span> (res === <span class="literal">false</span> &amp;&amp; <span class="built_in">this</span>.next) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.next.passRequest(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> console1 = <span class="keyword">new</span> Task(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">if</span>(a &gt; <span class="number">500</span>) <span class="keyword">return</span> <span class="string">&#x27;500+&#x27;</span>; <span class="keyword">return</span> <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> console300 = <span class="keyword">new</span> Task(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">if</span>(a &gt; <span class="number">300</span>) <span class="keyword">return</span> <span class="string">&#x27;300+&#x27;</span>; <span class="keyword">return</span> <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> console2 = <span class="keyword">new</span> Task(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">if</span> (a &gt; <span class="number">200</span>) <span class="keyword">return</span> <span class="string">&#x27;200+&#x27;</span>;<span class="keyword">return</span> <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> console3 = <span class="keyword">new</span> Task(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">if</span> (a &gt; <span class="number">100</span>) <span class="keyword">return</span> <span class="string">&#x27;100+&#x27;</span>;<span class="keyword">return</span> <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> normal = <span class="keyword">new</span> Task(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> <span class="string">&#x27;normal&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">console1.after(console300).after(console2).after(console3).after(normal)</span><br></pre></td></tr></table></figure><p>优缺点：解耦，只需要将请求传递给第一个节点即可<br>灵活地拆分重组<br>但是不能保证一定会被处理，</p><p>应用：优先度（比如选用下载工具。。。）</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>利用发布/订阅设计模式<br>最少知识法则<br>在中介者模式中，他们只能通过中介者对象来互相影响对方，使对象之间得以解耦</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>decorator<br>装饰者模式可以动态地给某个对象添加一些额外的职责，从而不影响这个从这个类中派生的其他对象。<br>在函数执行前后添加操作</p><p>可以处理数据上报、统计函数的执行时间、动态改变函数参数以及插件式的表单验证</p><p>作为一个框架，提供一下稳定以及方便移植的功能，使用装饰者模式动态装饰上去</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ol><li>SRP原则（单一职责原则）：引起变化的原因，如果有两个动机去写一个方法，那么这个方法就有两个职责。体现在一个对象只做一件事（单例模式、装饰着模式、代理模式）。降低了单个类或者对象的复杂度，利于单元测试，但是增大了对象之间的联系。</li><li>最少知识原则：一个实体应该尽量少地与其他实体发生作用（中介者模式、）</li><li>开放-封闭原则：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以增加代码的方式，但是不允许改动程序的源代码。发布订阅方法，策略模式，代理模式，职责链模式</li></ol><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-18-design-pattern/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NetWork/" itemprop="url" rel="index"><span itemprop="name">NetWork</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-18-http/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-18-http/" itemprop="url">HTTP</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1354</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h1><blockquote><p>GET与HEAD被RFC认为是一种安全方法，即不会再服务器上产生结果</p></blockquote><ol><li>GET将参数包含在URL中，POST通过<code>request body</code>传递参数</li><li>参数长度限制（http没有定义），浏览器会对其进行限制</li><li>GET提交数据没有POST安全，因为GET在地址栏上，其数据可以出现在URL上，因为GET数据可以缓存，有人查看浏览器历史记录就可能拿到</li><li>GET请求是幂等的，而POST请求是不幂等的</li><li>GET请求能缓存，POST不能</li><li>POST支持更多的编码类型且不对数据类型限制</li></ol><blockquote><p>幂等性是指一次或者多次请求某一个资源都应该具有同一个副作用。对同一个URL应该返回同样的结果</p></blockquote><p>(下面的不一定正确，浏览器不同而不同)<br>GET产生一个TCP数据包；POST产生两个TCP数据包</p><ol><li>对于GET请求，浏览器会把http header 和 data 一起发送出去，服务器相应200</li><li>对于POST，浏览器先发送header，服务器相应100 continue，浏览器再发送data，服务器相应200ok</li></ol><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>多路复用技术，只通过一个TCP连接就可以传输所有的请求数据，很好地解决了浏览器限制同一域名下的请求数量问题，同时更容易实现全速传输（新开TCP连接需要慢慢提升传输速度的）</p><h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>在之前的HTTP版本都是通过文本的方式传输数据的，在HTTP/2中引入了新的编码机制，所有传输的数据都会被分隔，并采用二进制格式编码</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在HTTP/2中，有两个非常重要的概念，分别是帧（frame）和流（stream）<br>帧代表着最小的数据单位，流就是多个帧组成的数据流，帧中包含着流的标识</p><p>多路复用就是一个TCP连接中可以存在多条流。换句话说，就是可以发送多个请求，对端可以通过识别帧中流的标识就可以知道是哪个请求了。通过这个技术可以结局HTTP中的队头阻塞问题。</p><h2 id="Header压缩"><a href="#Header压缩" class="headerlink" title="Header压缩"></a>Header压缩</h2><p>使用HPACK压缩格式对传输的header进行编码，同时在两端维护索引表，用于记录出现过的header。后面在传输过程中就可以传输已经记录过的键名了。（通过键名找到对应的值）</p><h2 id="服务端PUSH"><a href="#服务端PUSH" class="headerlink" title="服务端PUSH"></a>服务端PUSH</h2><p>服务端可以在客户端某个请求之后，主动推送其他资源。</p><h1 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h1><p>因为HTTP/2使用了多路复用，但是如果底层的TCP出现了丢包的情况，就会导致HTTP/2的表现情况反而不如HTTP/1了。</p><p>因为在丢包的情况下，整个TCP都要开始等待重传，导致了后面的数据被阻塞了。在HTTP/1中，开启了多个TCP连接，出现这种情况法尔只会影响到一个连接，剩余的TCP连接还是可以正常传输的。</p><p>基于这个原因，Google就基于UDP协议推出了一个QUIC协议，使用在了HTTP/3上。</p><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p>QUIC原生实现了多路复用功能，并且传输的单个数据流可以有序交付且不会影响其他的数据流。<br>QUIC在移动端表现优于TCP，因为TCP是基于IP和端口去识别连接的。这种方式在多变的移动端网络是脆弱的。但是QUIC通过ID的方式识别一个连接，不管网络环境如何变化，只要ID不变就可以迅速重连上。</p><h3 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h3><p>通过使用类似TCP的快速打开技术，缓存当前会话上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证就可以进行传输了。</p><h3 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h3><p>如果要发出三个包，那么协议会算出这三个包的异或值并且单独发出一个校验包，总共发出4个包<br>当出现非校验包丢包的情况下，可以通过另外三个包计算出丢失的数据包内容。（只能用于丢失一个包的情况下）</p><h1 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h1><p>请求行或状态行CRLF<br>首部行CRLF<br>空行(CRLF)<br>实体</p><h2 id="状态码和相应的短语"><a href="#状态码和相应的短语" class="headerlink" title="状态码和相应的短语"></a>状态码和相应的短语</h2><ul><li>1XX 信息性状态码，接收的请求正在处理<ul><li>100 Continue 等待状态码</li></ul></li><li>2XX 成功状态码，请求正常处理完毕<ul><li>200 OK</li><li>204 No Content</li><li>206 Partial Content</li></ul></li><li>3XX 重定向状态码，需要附加操作以完成请求<ul><li>301 Move Permanently 禁止从POST变成GET，但浏览器，原URL已经移除</li><li>302 Found 禁止从POST变成GET，但浏览器</li><li>303 See Other 从POST变成GET</li><li>304 Not Modified</li><li>307 Temporary Redirect 不会从POST变成GET</li></ul></li><li>4XX 客户端错误状态码，服务器无法处理请求<ul><li>400 Bad Request 存在语法错误</li><li>401 Unauthorized 需要认证，如果之前已经进行一次请求，表示认证失败</li><li>403 Forbidden</li><li>404 Not Found</li><li>412 Precondition Fail</li><li>417 Expectation Fail</li></ul></li><li>5XX 服务器错误状态码，服务器处理请求错误<ul><li>500 Inernal Server Error 执行请求出现错误</li><li>503 Service Unavailable 超负荷，停机维护</li><li>504 Gateway Timeout 网关等待服务器相应超时</li></ul></li></ul><h2 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h2><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-18-http/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-18-monitor/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-18-monitor/" itemprop="url">监控</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">219</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>前端监控主要分为三种：</p><ol><li>页面埋点</li><li>性能监控</li><li>异常监控</li></ol><h1 id="页面埋点"><a href="#页面埋点" class="headerlink" title="页面埋点"></a>页面埋点</h1><p>页面埋点一般监控以下几个数据</p><ul><li>PV/UB</li><li>停留时长</li><li>流量来源</li><li>用户交互</li></ul><blockquote><p>实现的思路主要分为手写埋点和无埋点的方式</p></blockquote><h1 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h1><ol><li>可以使用浏览器自带的Performance API来实现这个功能<br><code>performance.getEntriesByType(&#39;navigation&#39;)</code></li></ol><h1 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h1><ul><li>代码报错</li><li>接口异常上报</li></ul><p>代码报错：<br>一般可以通过拦截<code>window.onerror</code>来获得大部分详细的报错信息<br>对于跨域的代码运行错误会显示<code>Script error</code>，这种情况需要给<code>script</code>标签添加<code>crossorigin</code>属性</p><p>对于异步代码，可以通过catch的方式捕获错误</p><p>对于捕获的错误，可以通过一个img标签src简单发起一个请求</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-18-monitor/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-18-type-url-to-render/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-18-type-url-to-render/" itemprop="url">输入URL到页面渲染的整个流程</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">690</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><ol><li>解析URL</li><li>输入的是URL还是搜索关键字</li><li>转换非ASCII字符</li><li>检查HSTS（HTTP严格传输安全）列表，包含了那些请求浏览器只使用HTTPS进行连接的网站<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/caa80c7ad45c">Reason</a></li><li>DNS查询<ol><li>浏览器缓存</li><li>调用系统库方法<code>gethostbyname</code></li><li>检查host文件</li><li>检查缓存</li><li>发起请求</li></ol></li><li>Http请求（调用系统库函数socket，请求一个TCP流套接字）TCP/TLS</li><li>解析、渲染</li></ol><h1 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h1><p>Domain Name System</p><p>在TCP握手之前就已经进行DNS查询了，由操作系统来查询，当要访问<code>www.google.com</code>时候，会进行这样操作：</p><ol><li>检查hosts文件</li><li>操作系统会首先在本地的缓存中查询IP</li><li>如果没有的话就去系统配置的DNS服务器中查询</li><li>如果这时候还没有，会直接去DNS根服务器查询（根据是否启用转发模式），这一步会找出负责<code>com</code>这个一级域名的服务器</li><li>然后去该服务器查询<code>google</code>这个二级域名</li><li>接下来三级域名的查询其实我们配置的，可以给www这个域名配置一个IP，还可以给别的三级域名配置一个IP</li></ol><p>以上是DNS递归查询，还有一种是迭代查询:本地服务器将请求转发到根服务器</p><blockquote><p>当本地服务器代替客户端向其他服务器查询的时候，客户端完全处于等待状态<br>DNS查询DNS是应用层协议，是通过UDP进行的查询。DNS采用分布式集群的工作方式（单点故障，通信容量，远距离时间延迟，维护开销大）</p></blockquote><p>网址结构（从右往左）</p><ul><li>根域</li><li>顶级域（国家或者组织）</li><li>第二层域</li><li>子域</li><li>主机名</li></ul><p>使用UDP的原因：一次UDP名字交换可以短到两个包：一个查询宝和一个响应包。但是使用TCP的话，就需要9个包（其中3个握手4个挥手），开销大，所以前者（UDP）的效率很高。</p><p>DNS服务器一般分三种：根DNS服务器，顶级DNS服务器，权威DNS服务器<br>一般只有13个根服务器：<br>这是因为UDP数据包中512字节限制了信息量（又因为UDP报文中包含所有跟服务器的信息），所以只能有13个。</p><p>其实512是为了让UDP报文中不会因为size &gt; MTU而导致IP分片。IP分片发生后，只有一片有端口号，其他分片没有端口号，能否通过就取决于防火墙了，这对于是否通信成功是一个未知数。（以太网MTU=1500）</p><h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-18-type-url-to-render/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NetWork/" itemprop="url" rel="index"><span itemprop="name">NetWork</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-07-TCP-UDP/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-07-TCP-UDP/" itemprop="url">TCP/UDP</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">5196</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><p><strong>在TCP和UDP中，采用5个信息来识别一个通信：源IP，目标IP，源端口，目标端口，协议</strong>只要某一样不同就会被认为是其他通信。</p><p>端口号在传输层相当于地址，通过端口号来识别应用程序。</p><p>端口的确定：标准既定端口号（如http80，https443，ftp20，21，SMTP25，DNS53），以及动态分配法（由操作系统分配4w9到6w5）</p><p>不同的传输协议可以通过相同的端口号传输</p><p>二者区别：</p><ol><li>面向无连接/有连接（需要建立连接、无连接的可以不需，可以用于多播，广播等）</li><li>可靠性（UDP不关心是否收到数据，TCP采用超时重发、分片、流量控制，拥塞管理等保证可靠性）</li><li>高效性（UDP高效，报文段字节少，不需要建立连接），如DNS</li></ol><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>user datagram protocol<br>UDP协议是面向无连接的，也就是说不需要再正式传递数据之前连接双方，不保证数据的完整性和有序性<br>没有任何控制流量的算法，比TCP更加轻便</p><h2 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h2><p>UDP不需要想TCP一样需要三次握手建立连接</p><ul><li>在发送端，应用层将数据传递给传输层UDP协议，UDP只会给数据增加一个UDP头识别，然后传递给网络层</li><li>在接收端，网络层将数据传递给传输层，UDP只取出IP报文头就传递给应用层，不会任何拼接操作(不会分段)</li></ul><h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><p>发送数据不会关心对方是否已经正确接收到数据了。适用于某一些实时性要求高的场所</p><h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>UDP头部开销小，只有8byte，相比TCP20byte要小，传输报文的时候很高效</p><p>原因：</p><ol><li>无需建立连接</li><li>不需要确认收到数据</li><li>没有超时重发机制</li><li>没有流量控制和拥塞控制</li><li>报文段小</li></ol><p>UDP头部包含以下数据：</p><ul><li>两个16位的端口号，分别为源端口和目标端口</li><li>整个报文的长度Length</li><li>整个数据报文的校验和（IPv4可选字段），该字段用于发现头部信息和数据的错误</li></ul><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>UDP不止支持一对一的传输方式，同时支持一对多，多对多，多对一的方式。（单播，多播，广播）</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP建立连接和断开连接都需要进行握手，在传输数据的过程中，通过各种算法保证数据的可靠性。相比UDP不那么高效</p><p>TCP是面向连接的，可靠的流协议。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><ol><li>通过三次握手来建立连接</li><li>将数据截断为合理的长度（按照字节编号，合理分片），使数据包保持不变</li><li>超时重发机制（定时器超时前收不到母的段的确认报文段将重发）</li><li>对于收到的请求，给出确认相应（会推迟几分之一秒，用包的校验）</li><li>校验出包出错则丢弃报文段，不响应，让对方超时重发</li><li>丢弃重复的数据</li><li>进行流量控制</li><li>拥塞控制</li></ol><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><ul><li>2字节 * 2 源端口以及目标端口</li><li>4byte Sequence number 这个序号保证TCP传输的有序性，表明该报文携带数据第一个字符的序号（如果数据大小为100字节，那么下一次的序号为这次序号加上100）不会从0开始，而是建立连接时由计算机生成随机数通过SYN包发送到端主机。</li><li>4byte Acknowledgment number（if ACK set） 这个序号表示数据接收端期望接受的下一个字节的编号是多少，同时表示上一个序号为止的数据已经收到</li><li>2 byte 数据偏移位 + 保留位 + 标识符，其中每个标识符占1bit<ul><li>数据偏移位：长4bit，单位为4字节，表示从哪个位开始是数据</li><li>保留位：6/4</li><li>控制位：6/8</li></ul></li><li>2 byte window size 窗口大小，表示还能接受多少字节的数据，用于流量控制</li><li>2 byte checksum 校验和（区别与UDP，TCP的校验和无法关闭）<ul><li>计算过程：将所有16bit字节，反码相加，若大于16位则高位叠加，得到检验和。接收端采用同样的方法，如果得到1111则校验成功</li></ul></li><li>2 byte Urgent pointer（if URG set），紧急指针，说明紧急数据具有多少个字节</li><li>选项字段（长度可变），数据字段的最长度MSS</li><li>填充</li></ul><p>标识符*（控制位）：</p><ol><li>URG=1,本数据包部分包含紧急信息，是一个高优先级的数据报文。紧急数据一定位于当前数据包数据部分的最前面，紧急指针表明了紧急数据的尾部</li><li>ACK=1 表示确认好字段有效，<strong>TCP规定在连接建立之后传送的所有报文段都必须把ACK置为1</strong></li><li>PSH=1 该字段表示接收端应该立即将数据push给应用层，而不是等到缓冲区满了之后再提交</li><li>RST=1 表示当前TCP连接出现严重问题，可能需要重新建立TCP连接，也可以拒绝非法报文段和拒绝连接请求</li><li>SYN=1 SYN=1,ACK=0表示这是一个连接请求报文；当SYN=1,ACK=1表示这个一个同意连接的应答报文</li><li>FIN=1 表示这是一个释放连接的请求报文</li><li>CWR=1 且ECE=1表示拥塞窗口已经缩小</li><li>ECE=1 表示当前网络用拥塞</li></ol><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="建立链接的三次握手"><a href="#建立链接的三次握手" class="headerlink" title="建立链接的三次握手"></a>建立链接的三次握手</h3><p>客户端 发送 SYN</p><p>服务端 接收SYN，并返回 SYN + ACK，如果服务器无法立刻建立连接，返回RST报文报文表示重置</p><p>客户端 接收SYN + ACK，返回ACK</p><p>初期上方都处于<code>CLOSED</code>状态。在通信开始之前，双方会创建<code>TCB</code>。服务器创建完<code>TCB</code>之后就会进入<code>LISTEN</code>状态，单带客户端发送数据</p><p>第一次握手：</p><p>客户端发送一个<code>SYN</code>，然后进入<code>SYN-SENT</code>状态</p><p>第二次握手</p><p>服务端接收到<code>SYN</code>之后，返回<code>SYN + ACK</code>（包含数据初始序号）表示同意连接，发送之后进入<code>SYN-RECEIVED</code>状态</p><p>第三次握手</p><p>客户端接收到<code>SYN + ACK</code>之后，向服务器发送一个确认报文<code>ACK</code>，发送之后进入<code>ESTABLISHED</code>，服务端接收到这个应答之后也进入<code>ESTABLISHED</code>状态</p><blockquote><p>第三次握手可以包含数据</p></blockquote><p>需要第三次握手的原因是因为防止失效的连接请求报文段被服务端接收的情况：</p><p>假设客户端发送一个A请求，因为网络延迟，导致其又发了第二个请求B，请求B与服务端正确建立连接，通信结束后，如果请求A到达服务端，服务端可能会认为这是另一个通信请求，如果两步握手，服务端发送<code>SYN+ACK</code>之后进入<code>ESTABLISHED</code>状态，就需要一直等待客户端，浪费资源</p><p>MSS（Max Segment Size）是最大消息长度，理想状态下，最大消息长度正好是IP中不会被分片处理的最大数据长度</p><p>在握手的时候，两端的主机可以计算出这个数值，在TCP首部写入自己接口能够适应的MSS的大小。</p><h3 id="断开连接的四次挥手"><a href="#断开连接的四次挥手" class="headerlink" title="断开连接的四次挥手"></a>断开连接的四次挥手</h3><p>发送端：发送<code>FIN</code>请求释放连接，进入<code>FIN_WAIT_1</code>状态</p><p>接收端：接收到<code>FIN</code>请求，告诉应用层释放TCP连接。然后发送<code>ACK</code>包，表示可以继续发送数据，同时进入<code>CLOSE_WAIT</code>状态</p><p>发送端：发送端接收到<code>ACK</code>包之后，进入<code>FIN_WAIT_2</code>状态</p><p>接收端：当确认数据已经发送完毕了之后，发送<code>FIN</code>释放请求，然后进入<code>LAST_ACK</code>状态</p><p>发送端：收到<code>FIN</code>释放请求，发送<code>ACK</code>应答，然后进入<code>TIME_WAIT</code>状态，持续2MSL（最大段生存期），如果此时没有重发请求时，便进入<code>CLOSED</code>状态。</p><p>接收端：接收端接收到<code>ACK</code>应答，也进入<code>CLOASED</code>状态</p><p><picture><source srcset="/assets/images/TCP.webp" type="image/webp"><img loading="lazy" src="/assets/images/TCP.jpg" alt="TCP"></picture></p><h3 id="重发超时"><a href="#重发超时" class="headerlink" title="重发超时"></a>重发超时</h3><p>重发超时使指在重发数据之前，等待确认应答到来的那个特定的时间间隔。如果超过了这个时间仍没有收到确认应答，发送端将数据进行重发。</p><p>重发的时间长度使通过每次发包的时候都计算一下往返需要的时间以及偏差，将这个时间和偏差加起来，重发超时的时间就是比这个时间大一点。（因为有一些包是通过不同路径来的，所以偏差可能会大，也可能会小，为了使一些偏差大的也可以到达，不浪费网络流量）</p><p>如果数据重发了之后还是没有应答，则继续发送，等待时间将会以2倍，4倍等指数函数延长。但是数据包不会无限重发，如果重发超过了一定次数之后就会判断网络或对端主机出现了异常，强制关闭连接。并且通知应用程序强行终止。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>采用连续ARQ协议</p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在TCP中，两端其实都维护着窗口：发送端窗口和接收端窗口</p><p>动态调整窗口：</p><p>发送端窗口包含着已经发送但未收到应答的数据和可以发送但是未发送的数据，其中发送窗口是根据<strong>接收窗口的剩余大小</strong>决定的</p><p>接收方会把当前接收窗口的剩余带下写进应答报文，发送端会根据这个来调整发送窗口的值。</p><p>当发送端接收到应答之后，会将发送窗口进行滑动（它帮助TCP实现了流量控制功能，接收方通过告知发送方还可以发送多少数据来保证接收方能够来得及接收数据，防止出现接收方宽带已满，但是发送方还一直发送数据的情况）</p><h4 id="Zero-窗口"><a href="#Zero-窗口" class="headerlink" title="Zero 窗口"></a>Zero 窗口</h4><p>在发送报文的时候，可能会出现零窗口的情况，在这种情况下，发送端会停止发送数据，并启动persistent timer，该定时器会定时发送请求到对端，让其告知窗口大小。在重试超过一定次数之后，可能会终端TCP连接。</p><p>在窗口在一定程度上大的时候，即使少部分确认应答丢失也不会重发，可以通过确认下一个应答来确认。</p><p>如果连续3次收到同一个应答，就会对对应的数据进行重发。（快速重传，见下方）</p><p>死锁</p><p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p><p>为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p><h3 id="传输效率（提高网络利用率）"><a href="#传输效率（提高网络利用率）" class="headerlink" title="传输效率（提高网络利用率）"></a>传输效率（提高网络利用率）</h3><ol><li>Nagle算法：</li></ol><p>发送端即使还有应该发送的数据，但是如果这部分数据很少的话，那么进行延迟发送的一种的处理机制。仅在下面两个条件都不满足的时候，暂时等待一段时间再发送。</p><ul><li>已发送的数据都已经确认应答时</li><li>可以发送最大段（MSS）数据时</li><li>紧急数据发送</li><li>等待超过一段时间</li></ul><p>缺点：造成了延迟，所以一些机械控制领域中使用TCP时，往往会关闭这个算法。<br>优点：减少大量的小包在网络上造成拥塞</p><ol start="2"><li><p>延迟确认应答</p></li><li><p>削带应答<br>计算机既要应答，也要发送数据的情况</p></li></ol><h2 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h2><p>拥塞处理和流量控制不同，后者作用于接收方，保证接收方来得及接收数据。前者作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>算法：</p><ul><li>慢启动算法</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul><h3 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h3><p>在传输开始的将发送窗口慢慢指数扩大，从而避免一开始传输大量数据导致网络拥塞。</p><ol><li>连接初期设置拥塞窗口(Congestion Window)为1 MSS（一个分段的最大数据量）</li><li>每过一个RTT就将窗口大小乘2</li><li>当窗口大小大于一个阈值时就会启动拥塞避免算法<br>（TCP在通信开始的时候没有设置阈值，只有在第一次重传超时的时候才会设置为当前窗口的一半）</li></ol><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h3><p>拥塞避免算法每过一个RTT窗口大小只加1，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值</p><p>在传输过程中可能定时器超时的情况，这时候TCP认为网络拥塞了，会马上进行以下步骤：</p><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为1 MSS</li><li>启动慢开始算法</li></ol><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>快速重传一般和快速恢复一起出现。<br>如果接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的ACK，无需等待定时器超时而是直接启动快速重传算法。</p><p>TCP Reno算法：</p><ul><li>拥塞窗口减半</li><li>将阈值设置为当前拥塞窗口</li><li>进入快恢复阶段（一旦收到一个新的ACK答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><p>TCP New Ren 改进后的快恢复：</p><p>TCP发送端会记下三个重复ACK的分段的最大序号</p><p>假设有一个1 - 10十个序号的报文，如果丢失了3 和 7的报文，那么该分段最大序号就是10。</p><p>这时候重发序号为3的报文，接收方接收后发送7的应答，此时TCP继续发送序号为7的报文，接收方接收后发送ACK序号为11的应答，此时发送端可以认为这个分段接收端已经顺利接收，接下来退出快恢复阶段。</p><p>快恢复阶段阶段不执行慢启动算法。因为同时收到3个包，说明了当前网络不处于拥塞环境，直接使用拥塞避免算法。</p><h2 id="建立连接后保持为连接"><a href="#建立连接后保持为连接" class="headerlink" title="建立连接后保持为连接"></a>建立连接后保持为连接</h2><ol><li>TCP协议成keep alive机制</li></ol><p>连接闲置后一段时间，发送一个keepalive探测包</p><p>对方收到之后会回复ACK</p><p>如果出现错误就恢复一个RST</p><p>如果没有多次没有回复则视为断开</p><ol start="2"><li>应用层实现心跳包</li></ol><ul><li>客户端定时发送一个心跳包，告诉自己仍然在线</li></ul><h2 id="TCP异常"><a href="#TCP异常" class="headerlink" title="TCP异常"></a>TCP异常</h2><ol><li><p>与一个不存在的端口建立连接</p><ul><li>服务器端口没有监听这个端口，那么客户端发送的请求(SYN)就会在服务器的系统内出发RST分节的条件，表示出错。客户端的TCP接收到这个RST之后就会放弃连接，并且返回应用程序一个错误。</li></ul></li><li><p>与不存在主机上的端口建立连接</p><ul><li>TCP没有任何相应，6s后会继续发送一个SYN，如果还是没有反应，24S后再发送一个，总共等待75s。如果还没有收到相应就会返回ETIMEOUT错误</li></ul></li><li><p>Server进程被塞满</p><ul><li>这时候连接可以正常建立（因为建立连接的进程对于应用程序来说是不可见的），客户端可以发数据给服务端，同时服务端TCP会应答ACK表示已经收到分节（数据在内核缓冲区，但是因为应用程序进程被阻塞，所以不能将数据从内核缓冲区复制到应用层序的缓冲区）</li></ul></li><li><p>kill Server</p><ul><li>在程序正常退出的时候会自动调用close函数关闭它打开的文件描述符，相当于服务器主动关闭连接（发送一个FIN给客户端）<br>客户端需要配合对端关闭连接</li></ul></li><li><p>Server所在主机关机</p><ul><li>系统关闭时，init进程会给所有进程发送SIGTERM信号，等待一段时间（5-20s），再给所有仍在运行的进程发送SIGKILL信号。当服务器进程死掉时，会关闭所有的文件描述符。</li></ul></li><li><p>Server进程所在的主机宕机</p><ul><li>客户端持续重传分节，试图从服务器中接受到一个ACK，重传数次之后，大约4-10分钟停止，返回一个ETIMEOUT错误</li><li>TCP提供一个SO_KEEPALVE的socket选项，应用程序每隔一段时间发送对方一个心跳包，当对方没有相应的时候会以更短的时间间隔发送，一段时间之后仍无反应就断开这个连接。</li><li>如果服务器接收到报文段，那么就会回复一个RST表示出错</li></ul></li><li><p>模糊窗口综合征</p><ul><li>发送端产生数据慢，一产生就发送; 接收端消费数据慢，每次发送确认报文设置窗口大小为1<br>导致了大量小包发送</li><li>解决：<ul><li>nagle算法，延迟发送</li><li>延迟应答</li><li>或者收到数据宣布窗口为0，待缓冲区有足够空间的时候</li></ul></li></ul></li><li><p>黏包<br>UDP不会发生黏包，因为有明确的边界</p></li></ol><p>原因：</p><ol><li>Nagle算法造成的发送端黏包</li><li>接收端接收不及时，倒是TCP缓冲区存放几段数据</li></ol><p>解决：</p><ol><li>关闭Nagle算法</li><li>接收端尽可块从缓冲区读取数据</li><li>发送数据在开头和结尾标记</li></ol><h1 id="TCP提供可靠的数据传输"><a href="#TCP提供可靠的数据传输" class="headerlink" title="TCP提供可靠的数据传输"></a>TCP提供可靠的数据传输</h1><p>实行顺序控制或者重发控制机制，还具备流量控制，拥塞控制，提高网络利用率等众多功能</p><h1 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h1><p>(Automatic Repeat-reQuest) 自动重传请求<br>通过<strong>确认</strong>和<strong>超时</strong>两个机制，实现可靠的信息传输</p><ul><li>停止等待ARQ协议</li><li>连续ARQ协议</li></ul><h2 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a>停止等待ARQ协议</h2><h3 id="正常传输过程"><a href="#正常传输过程" class="headerlink" title="正常传输过程"></a>正常传输过程</h3><p>只要A向B发送一段报文，都要停止发送并启动一个计时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p><h3 id="报文丢失或出错"><a href="#报文丢失或出错" class="headerlink" title="报文丢失或出错"></a>报文丢失或出错</h3><p>在报文传输阶段可能出现丢包，这时候定时器设定的时间就会再次发送丢失的数据知道对端的相应，所以需要每次都备份发送的数据。。</p><p>即使报文正常传输到了对端，可能出现传输过程中报文出错的问题。这时候会抛弃该报文并等待A段重传</p><h3 id="ACK-超时或者丢失"><a href="#ACK-超时或者丢失" class="headerlink" title="ACK 超时或者丢失"></a>ACK 超时或者丢失</h3><p>对端传输的应答也有可能丢失导致超时，这样A端会重传报文，如果B端收到了相同序号的报文会丢弃该报文并重传应答，直到A端发送下一个序号的报文</p><h2 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h2><p>在连续ARQ中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待ARQ减少了等待时间，提高了效率。</p><h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><p>接收端会通过累计确认，在收到多个报文以后统一回复一个应答报文，报文中的ACK标识可以告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p><p>弊端：可能会造成发送端重复发送数据的情况</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-07-TCP-UDP/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-21-javascript-interview/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-21-javascript-interview/" itemprop="url">JavaScript 易错</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">4087</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h1><h2 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h2><ol><li>字符方法<ul><li>charAt</li><li>charCodeAt</li><li>codePointAt</li></ul></li><li>拼接方法<ul><li>concat</li><li>slice 如果start大于end，则返回空字符串</li><li>substr</li><li>substring 若start大于end，那么二者会交换，任何大于length都会被视为length<blockquote><p>上面三者都接受两个参数，其中<code>slice</code>和<code>substring</code>两个接受起始位置和终止位置，但是<code>substr</code>接受一个起始位置和返回的字符串长度<br>如果输入负数，<code>slice</code>会加上数组长度，<code>substring</code>则会将所有负数转化为0，<code>substr</code>第一个负的参数加上字符串长度，第二个转化为0<br>如果输入NaN,视为0<br>如果开始和结束相等，返回空字符串</p></blockquote></li></ul></li><li>索引方法<ul><li>indexOf</li><li>lastIndexOf</li><li>startsWith</li><li>endsWith</li><li>includes</li><li>repeat</li></ul></li><li>trim方法<ul><li>trim 删除所有前置和后置空格</li></ul></li><li>大小写方法<ul><li>toUpperCase</li><li>toLowerCase</li><li>toLocaleLowerCase</li><li>toLocaleUpperCase</li></ul></li><li>匹配方法<ul><li>match 返回一个符合正则表达式的数组，而exec方法则会返回一个符合正则表达式的数组外，还有捕获组以及index和input的属性</li><li>replace 第一个参数为字符串或者正则，如果没有设定g flag，那么指挥替换第一个</li><li>search 从头往后查找模式，如果存在则返回索引，如果没有就返回-1</li></ul></li><li>比较<ul><li>localeCompare 如果字符串在字母表中中应该排在字符串参数之前，返回一个负数，如果字符串等于字符串参数，返回0，如果应该排在字符串参数之后，返回1</li></ul></li><li>String方法<ul><li>String.fromCharCode</li><li>String.fromCodePoint</li></ul></li></ol><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><ul><li>转换错误<ul><li>给未声明的变量赋值会报错 （不可以意外地创建全局变量）</li><li>分配无效报错（比如writable设置为false的量，undefined和NaN赋值）TypeError，在正常模式下不会报错</li><li>尝试delete一个无法delete的变量时候出错TypeError</li><li>函数参数的名称的唯一的</li><li>严格禁止8进制，如果有前导0会报错</li><li>在原始值上设置属性，抛出TypeError</li></ul></li><li>简化变量的使用<ul><li>禁止with，否则不知道在内部定义的变量是全局的还是obj的（编译器可以很好地优化代码）</li><li>eval变量不影响外部作用于</li><li>禁止删除普通名称（不是对象的属性）</li></ul></li><li>argument<ul><li>argument不跟踪相应的命名参数的值</li><li>argumen.callee不再支持</li></ul></li><li>this<ul><li>this将不会自动转化成对象（如apply等需要自己显式传this对象）</li><li>指向window的this将会变成undefined、</li></ul></li><li>新增保留关键字</li></ul><h1 id="call、apply和bind的区别"><a href="#call、apply和bind的区别" class="headerlink" title="call、apply和bind的区别"></a>call、apply和bind的区别</h1><ul><li>其中bind返回一个函数，call和apply直接执行</li><li>call接受一个this参数以及…args（多个argument参数）</li><li>apply接受一个this参数以及args数组或者类数组（NodeList以及HTMLCollection，argument之类的）</li><li>bind接受一个this参数以及若干参数，柯里化</li><li>实现bind要点<br>注意验证this是否函数<br>验证是否new调用（使用new.target判断）<br>将参数封装<br>（A.apply(Object.create(A.prototype))，此时instanceOf就会误判）</li></ul><h1 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h1><p>fetch<br>用法：</p><ul><li>const xhr = new XMLHttpRequest()</li><li>xhr.open(method, url, ?async, username, psw) 启动一个请求以备发送</li><li>xhr.send(data)主体，如果不需要通过主体发送数据，则必须传入null（某些浏览器必须的）</li><li>请求完成后，属性会填充再xhr对象里面：<ul><li>responseText</li><li>responseType</li><li>responseURL</li><li>responseXML</li><li>response</li><li>statusText</li><li>status<br>方法：</li></ul></li><li>setRequestHeader()，必须在open之后，send之前</li><li>send()</li><li>getResponseHeader()</li><li>getAllResponseHeaders() 由<code>CRLF</code>分隔的所有响应头，如字符串，或者null（没有收到响应）</li><li>abort() 如果请求已经发送，则终止请求。然后将状态设置为UNSENT</li><li>onprogress()</li><li>overrideMimeType 可以设置自定义类型，上传时候可以使用</li><li>.timeout 设置超时</li></ul><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>xhr.readyState，返回请求的状态。<br>xhr.onreadystatechange</p><p>readystate：</p><ul><li>0 UNSENT 对象创建，未open</li><li>1 OPENED 已经open，未send</li><li>2 HEADERS_RECEIVED 响应头和相应状态已经返回</li><li>3 LOADING 响应体下载中</li><li>4 DONE 请求完成</li></ul><p>事件：（同下）</p><h2 id="XMLHttpRequest-upload"><a href="#XMLHttpRequest-upload" class="headerlink" title="XMLHttpRequest.upload"></a>XMLHttpRequest.upload</h2><p>该方法返回一个XMLHttpRequestUpload对象，可以用来监视上传的进度<br>事件：</p><ul><li>loadstart 上传开始</li><li>progress 上传进度</li><li>abort 上传终止</li><li>error 错误，上传失败</li><li>load 上传成功</li><li>timeout 上传超时</li><li>loadend 上传结束，无论是load还是timeout还是error，都会触发这个事件</li></ul><p>如果拔出网线，则会：</p><ol><li>如果上传结束，那么触发xhr.onerror</li><li>如果上传未完成，那么触发xhr.onerror以及触发xhr.upload.onerror</li></ol><h2 id="兼容性问题"><a href="#兼容性问题" class="headerlink" title="兼容性问题"></a>兼容性问题</h2><ol><li>IE11不支持responseType为json</li><li>某些低版本firefox和chrome不支持.timeout</li></ol><h2 id="XMLHttpRequest-Level-2"><a href="#XMLHttpRequest-Level-2" class="headerlink" title="XMLHttpRequest Level 2"></a>XMLHttpRequest Level 2</h2><ol><li>uploading progress events</li><li>uploading/doloading binary data.</li></ol><blockquote><p>Blob Binary Large Object, 二进制大对象。Blob对象是二进制数据，类似于文件对象的二进制对象。File继承自Blob<br><code>Blob(blobParts [, option])</code> 第一个数组类型，如果数组内是对象，则会调用<code>toString()</code>方法<br>blob url 可以通过<code>URL.createBlobURL()</code>创建。（前端代码生成，供浏览器下载）<br>DATA URL 一般不是所有浏览器都支持通过XMLHttpRequest获取资源的，但是blob URL可以通过这个获取资源。bolb url一般比data url 要短<br>form data</p></blockquote><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h1 id="页面间通讯"><a href="#页面间通讯" class="headerlink" title="页面间通讯"></a>页面间通讯</h1><ol><li>通过window.open打开，获得window对象，然后通过操作或者通过postMessage来进行通讯，缺点是只能与自己打开的页面进行通讯，应用面窄。但是在跨域中依旧可以进行通讯</li><li>localStorage<br>设置共享区域的storage，storage会触发storage事件<br><code>window.onStorage</code><br>写入操作的页面下不会触发事件<br>重复设置相同值不会触发</li></ol><blockquote><p>由于sessionStorage只存在一个tab，没出现一个新的tab，都会产生一个新的sessionStorage</p></blockquote><h1 id="promise的实现"><a href="#promise的实现" class="headerlink" title="promise的实现"></a>promise的实现</h1><ul><li>then返回一个promise</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>浅拷贝 Array.from()，解构（迭代器）</li><li>深拷贝<ul><li>注意环、对象数组</li><li>特殊类型的值</li><li>方案：递归、JSON（JSON遇到环会报错，无法解析函数，对象忽略undefined，symbol，数组将NaN、null、undefined、infinity，symbol变成null）</li></ul></li><li>判断是否数组方法：<ul><li>Array.isArray()</li><li>Object.prototype.toString.call()</li><li>instanceOf 这个方法不准确</li></ul></li></ul><h1 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt"></a>parseInt</h1><p>第二个参数代表进制</p><h1 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h1><ul><li>join(‘’)</li><li>直接调用 + ，自动转换</li><li>迭代</li><li>reduce</li></ul><h1 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h1><ul><li>split()</li><li>迭代</li></ul><h1 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h1><ol><li>Number/ + / 等操作符</li><li>parseInt</li><li>parseFloat</li></ol><h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序。<br>IE的事件流是事件冒泡流，网景的是事件捕获流</p><p>DOM2规定的时间流包括三个阶段：事件捕获阶段、处于目标阶段以及事件冒泡阶段。</p><blockquote><p>规范要求，捕获阶段不会涉及事件目标</p></blockquote><h2 id="Event对象上的3-5个属性或者方法"><a href="#Event对象上的3-5个属性或者方法" class="headerlink" title="Event对象上的3-5个属性或者方法"></a>Event对象上的3-5个属性或者方法</h2><ol><li>event.target</li><li>event.stopPropagation</li><li>event.preventDefault</li><li>event.currentTarget</li><li>各种按键以及相对位置</li></ol><h2 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h2><ul><li>event.stopPropagation()</li><li>window.event.cancelBubble = true //ie</li></ul><h2 id="取消默认行为"><a href="#取消默认行为" class="headerlink" title="取消默认行为"></a>取消默认行为</h2><ul><li>event.preventDefault()</li><li>window.event.returnValue = false // ie</li></ul><h2 id="兼容写法"><a href="#兼容写法" class="headerlink" title="兼容写法"></a>兼容写法</h2><blockquote><p>ie9兼容addEventListener写法</p></blockquote><ol><li>addEventListener(‘’, fn, false) attachEvent(‘on..’, fn)</li><li>removeEventListener(‘’, fn, false) detachEvent(‘on..’, fn)=43</li></ol><h2 id="React的事件处理机制"><a href="#React的事件处理机制" class="headerlink" title="React的事件处理机制"></a>React的事件处理机制</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/entry/59ce08f3518825276f49fc40">React事件机制</a><br><a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/master/packages/react-dom/src/events/ReactBrowserEventEmitter.js">Source源码</a></p><ol><li>几乎所有的事件代理(delegate)到<code>document</code>，达到性能优化的目的</li><li>对于每种类型的事件，拥有统一分发的函数<code>dispatchEvent</code></li><li>事件对象event是合成对象（SyntheticEvent），不是原生事件</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>事件注册：<ul><li>React在组件加载和更新时候，<code>ReactDOMComponent</code>会对事件属性进行处理，对相关事件进行注册和存储。document中注册的事件不处理具体事件，而是对事件进行分发。<code>ReactBrowserEventEmitter.listenTo</code>作为事件注册的入口，担负着事件注册和事件触发。注册事件的回调函数由<code>EventPluginHub</code>来统一管理(采用<code>listenerBank</code>来进行处理)，根据事件的类型（type）和组件标识（_rootNodeID）为key唯一标识事件并进行存储。</li></ul></li><li>事件执行：<ul><li>事件执行的时候，document上绑定事件<code>ReactEventListener.dispatchEvent</code>会对事件进行分发，先获取原生对象的<code>target</code>,然后找到组件实例。循环将所有父组件获取，保存在数组中。<br><code>ReactEventEmitter</code>利用<code>EventPluginHub</code>中注入的<code>plugins</code>将原生事件转化为合成事件，然后批量执行存储的回调函数。<br>回调函数执行的时候分为两步，第一步将所有合成事件放到<code>事件队列</code>里面，第二部是逐个执行。浏览器原生会为每一个事件的每个listener创建一个事件对象，但是这会造成高额内存分配，所以React在启动的时候就为每种对象分配内存池，用到某一个事件对象的时候可以从内存池中复用，节省内存。(对应享元模式)</li></ul></li><li>无法使用<code>event.stopPropagation()</code>停止事件传播，需要使用React定义的<code>event.preventDefault</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  - Top-level delegation is used to trap most native browser events. This</span></span><br><span class="line"><span class="comment"> *    may only occur in the main thread and is the responsibility of</span></span><br><span class="line"><span class="comment"> *    ReactDOMEventListener, which is injected and can therefore support</span></span><br><span class="line"><span class="comment"> *    pluggable event sources. This is the only work that occurs in the main</span></span><br><span class="line"><span class="comment"> *    thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - We normalize and de-duplicate events to account for browser quirks. This</span></span><br><span class="line"><span class="comment"> *    may be done in the worker thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - Forward these native events (with the associated top-level type used to</span></span><br><span class="line"><span class="comment"> *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want</span></span><br><span class="line"><span class="comment"> *    to extract any synthetic events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` will then process each event by annotating them with</span></span><br><span class="line"><span class="comment"> *    &quot;dispatches&quot;, a sequence of listeners and IDs that care about that event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - The `EventPluginHub` then dispatches the events.</span></span><br><span class="line"><span class="comment"> * Overview of React and the event system:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * |    DOM     |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> *       |           .</span></span><br><span class="line"><span class="comment"> *       v           .</span></span><br><span class="line"><span class="comment"> * +------------+    .</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .</span></span><br><span class="line"><span class="comment"> * |  Listener  |    .</span></span><br><span class="line"><span class="comment"> * +------------+    .                         +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .               +--------+|SimpleEvent|</span></span><br><span class="line"><span class="comment"> *       |           .               |         |Plugin     |</span></span><br><span class="line"><span class="comment"> * +-----|------+    .               v         +-----------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+                    +------------+</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  | Propagators|</span></span><br><span class="line"><span class="comment"> * | ReactEvent |    .    |              |     |TapEvent   |  |------------|</span></span><br><span class="line"><span class="comment"> * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|</span></span><br><span class="line"><span class="comment"> * |            |    .    |              |     +-----------+  |  utilities |</span></span><br><span class="line"><span class="comment"> * |     +-----------.---&gt;|              |                    +------------+</span></span><br><span class="line"><span class="comment"> * |     |      |    .    +--------------+</span></span><br><span class="line"><span class="comment"> * +-----|------+    .                ^        +-----------+</span></span><br><span class="line"><span class="comment"> *       |           .                |        |Enter/Leave|</span></span><br><span class="line"><span class="comment"> *       +           .                +-------+|Plugin     |</span></span><br><span class="line"><span class="comment"> * +-------------+   .                         +-----------+</span></span><br><span class="line"><span class="comment"> * | application |   .</span></span><br><span class="line"><span class="comment"> * |-------------|   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * |             |   .</span></span><br><span class="line"><span class="comment"> * +-------------+   .</span></span><br><span class="line"><span class="comment"> *                   .</span></span><br><span class="line"><span class="comment"> *    React Core     .  General Purpose Event Plugin System</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="JS上下文"><a href="#JS上下文" class="headerlink" title="JS上下文"></a>JS上下文</h1><p>作用域（scope）与上下文（context）是不同的。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域包括：全局作用域、局部作用域（函数作用域）、块作用域（es6）</p><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>上下文是指定代码特定部分中的this值<br>全局作用域中this为window，函数中的this取决于调用时环境，箭头函数取决于词法作用域（声明时绑定，不可更改绑定）<br>函数中this还会受到这些影响：bind、call、new、apply</p><p>严格模式下，函数上下文默认为undefined<br><a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS">You-Dont-Know-JS</a></p><h1 id="继承-amp-原型链"><a href="#继承-amp-原型链" class="headerlink" title="继承 &amp; 原型链"></a>继承 &amp; 原型链</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h2 id="使用new操作符的时候发生了什么"><a href="#使用new操作符的时候发生了什么" class="headerlink" title="使用new操作符的时候发生了什么"></a>使用new操作符的时候发生了什么</h2><ol><li>创建一个对象</li><li>将这个对象的原型指向构造函数的原型</li><li>将this指向这个对象</li><li>执行代码</li><li>判断返回是否为一个对象，如果是，则返回结果，如果不是，则返回这个对象</li></ol><h2 id="实现继承的方法"><a href="#实现继承的方法" class="headerlink" title="实现继承的方法"></a>实现继承的方法</h2><ol><li>Object.create</li><li>extends<br>与组合继承相比：<ul><li>能够继承静态方法</li><li>extends继承与call不同，call是一开始就指定了this，导致无法调用基类的某些功能，但是extends是访问基类功能之后才修改this</li></ul></li><li>组合继承</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name) <span class="comment">//借用构造函数</span></span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="built_in">this</span>.age)&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>借用构造函数</li></ol><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ul><li>工厂模式，方法无法共用，无法通过constructor识别对象</li><li>构造函数方式，可以通过constructor识别对象，instanceof可以识别对象，通过new来创建实例，方法无法共用</li><li>原型模式，对于引用类型会出现共用的情况</li><li>构造函数和原型组合模式，解决了上面的缺点：引用类型，共享方法（<strong>一般采用的方法</strong>）</li><li>动态原型方法（完美方案）添加一个条件判断，如果原型上由该方法就不再创建</li><li>稳妥构造</li><li>寄生构造</li></ul><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>作用：</p><ul><li>作为对象使用</li><li>作为函数调用</li><li>作为构造函数调用</li><li>bind/apply/call</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>作用域链中包含了上一层作用域，所以即使上一层的作用域所在的函数执行完毕，该函数还是保留着作用域的引用，即可以访问到作用域的变量<br>应用：</p><ol><li>模拟私有变量，例如debounce</li><li>单例模式</li><li>柯里化</li></ol><h1 id="异步流程控制方法"><a href="#异步流程控制方法" class="headerlink" title="异步流程控制方法"></a>异步流程控制方法</h1><ul><li>setTimeout\setInterval</li><li>requestAnimationFrame/ requestIdleCallback</li><li>Promise</li><li>async/await</li><li>xhr…</li><li>worker</li></ul><h2 id="promise-实现"><a href="#promise-实现" class="headerlink" title="promise 实现"></a>promise 实现</h2><p>要点：</p><ol><li>resolve, reject, then, catch,</li><li>resolve 中 setTimeout 延时</li><li>判断状态，then方法中状态如果为fulfilled就直接调用</li><li>链式调用，then方法以及catch方法会返回一个promise</li></ol><h2 id="async-await实现"><a href="#async-await实现" class="headerlink" title="async/await实现"></a>async/await实现</h2><h2 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a>ES2016</h2><ul><li>Array.prototype.includes</li><li>** 幂运算符</li></ul><h2 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a>ES2017</h2><ul><li>Object.values() // 跟Object.keys()类似</li><li>Object.entries() // 可以直接将Object转化为Map</li><li>string.padStart(num, str) &amp; padEnd() 在字符串首尾添加字符(指定数量和字符)</li><li>Object.getOwnPropertyDescriptor</li><li>Async/Await</li></ul><h3 id="asyn-await处理错误的方法"><a href="#asyn-await处理错误的方法" class="headerlink" title="asyn/await处理错误的方法"></a>asyn/await处理错误的方法</h3><p>由于await返回一个promise，所以我们可以在await后面直接执行catch进行处理错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> someAction().catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以对整个函数catch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test().catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e))</span><br></pre></td></tr></table></figure><p>通用方法：<code>try-catch</code>块</p><h2 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a>ES2018</h2><ul><li>promise.prototype.finally()</li><li>异步循环 for-await-of</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> obj <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj) <span class="comment">// 输出1, 2, 3  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则：unicode转义、lookbehind断言即<code>(?&lt;=)</code>之类的、使用命名组Named Group、点<code>.</code>匹配所有字符（空白字符）(s flag)</li><li>对象的<code>...</code>操作</li><li>带标签的模板字面量限制被移除</li><li>共享内存和原子性，由之前JS引擎管理内存变成自己管理内存。(SharedArrayBuffer)这个区域可以被主线程和<code>web-worker</code>共享，即多线程共用，引入原子性的全局对象提供多种方法保证正在被某个县城访问你的内存被锁住</li></ul><h1 id="HTMLEncode通常在哪个阶段做"><a href="#HTMLEncode通常在哪个阶段做" class="headerlink" title="HTMLEncode通常在哪个阶段做"></a>HTMLEncode通常在哪个阶段做</h1><ul><li>将变量输出到HTML的时候做，如渲染模板的时候</li><li>可以破解：</li></ul><h1 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 !== 0.3"></a>0.1 + 0.2 !== 0.3</h1><p><a target="_blank" rel="noopener" href="https://medium.com/dailyjs/javascripts-number-type-8d59199db1b6">JavaScript’s Number type</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>全局上下文中的变量对象就是全局对象</p><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象（activation object，AO）来表示变量对象</p><p>只有当进入一个执行上下文中，这个执行上下文的变量对象才被激活，只有被激活的活动对象，也就是活动对象上各种属性才能被访问。</p><p>活动对象是进入函数上下文时刻被创建，它通过函数的argument属性初始化。arguments属性值是arguments对象</p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码分成两个阶段执行：</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文的时候，此时还没有执行代码<br>变量对象包括：</p><ol><li>函数所有形参，如果没有，属性值设置为undefined</li><li>函数声明，由名称和对应值组成一个变量对象的属性被创建，如果变量对象已经存在相同名称的属性，则完成替换</li><li>变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ol><h2 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h2><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h2 id="URL到展现"><a href="#URL到展现" class="headerlink" title="URL到展现"></a>URL到展现</h2><ol><li>加载慢怎么优化</li></ol><h2 id="React出现的意义"><a href="#React出现的意义" class="headerlink" title="React出现的意义"></a>React出现的意义</h2><ol><li>自由</li></ol><h2 id="React的优化（空间大）"><a href="#React的优化（空间大）" class="headerlink" title="React的优化（空间大）"></a>React的优化（空间大）</h2><ul><li>redux</li><li>shouldComponentUpdate</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h2 id="resful-API"><a href="#resful-API" class="headerlink" title="resful API"></a>resful API</h2><ul><li>动词 + 宾语（HTTP），如果服务器只接受两种方法（GET与POST），必须使用<code>X-HTTP-Override: Method</code>来指定</li><li>宾语是名词，即URL下的目录一般都要求是名词</li><li>避免多级URL，这种URL不利于拓展，一般除了第一级其他都使用查询字符串表示</li><li>状态码必须精确，发生错误的时候不要返回200</li><li>服务器回应要设为JSON格式，不要纯文本。（客户端请求时也要将ACCEPT设置为JSON）</li></ul><h2 id="静态资源放在另一个服务器上"><a href="#静态资源放在另一个服务器上" class="headerlink" title="静态资源放在另一个服务器上"></a>静态资源放在另一个服务器上</h2><ol><li>不携带cookie，节省流量</li><li>浏览器对一个域名有访问上限</li><li>CDN</li></ol><h2 id="canvas优化性能的方法"><a href="#canvas优化性能的方法" class="headerlink" title="canvas优化性能的方法"></a>canvas优化性能的方法</h2><ol><li>预渲染</li><li>所有点一起绘制</li><li>重绘不需要清除整个画布</li><li>多个画布一起工作</li><li>requestAnimationFrame</li><li>GPU</li></ol><h2 id="webpack底层实现原理"><a href="#webpack底层实现原理" class="headerlink" title="webpack底层实现原理"></a>webpack底层实现原理</h2><h2 id="判断图片是否加载完成：onload-amp-onerror"><a href="#判断图片是否加载完成：onload-amp-onerror" class="headerlink" title="判断图片是否加载完成：onload &amp; onerror"></a>判断图片是否加载完成：onload &amp; onerror</h2><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-21-javascript-interview/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fas fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/images/card.webp" type="image/webp"><img loading="lazy" class="site-author-image" itemprop="image" src="/images/card.jpg" alt=""></picture><p class="site-author-name" itemprop="name">everbrez</p><p class="site-description motion-element" itemprop="description">你能抓到我么？</p></div><div class="links-of-author motion-element"><span class="links-of-author-item scaleup"><a href="https://github.com/everbrez" target="_blank" title="GitHub"><i class="fab fa-github" style="color:#191717"><span>everbrez</span></i></a></span></div><div class="des-of-author"><div class="des-of-author-nav"><div class="des-of-author-title active" data-index="1">最喜欢的作品</div><div class="des-of-author-title" data-index="2">最喜欢的女孩子</div><div class="des-of-author-title" data-index="3">最喜欢的游戏</div></div><div class="des-of-author-panel"><div class="des-of-author-des active" data-index="1">路人女主的养成方法、我的青春恋爱物语果然有问题</div><div class="des-of-author-des" data-index="2">加藤惠</div><div class="des-of-author-des" data-index="3">Minecraft</div></div></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.png"></picture></div><div class="footer-inner"><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>© <span itemprop="copyrightYear">2021</span> Hi, いざよい. 由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动. Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.74. <a href="/sitemap.xml" target="_blank">站点地图</a>.</p><p>Made with <i class="fas fa-heart throb" style="color:#d43f57"></i> by <span class="author" itemprop="copyrightHolder">everbrez</span>.</p></div></footer><div class="back-to-top"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.png"></picture></div><canvas id="evanyou"></canvas></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.74"></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js")})</script></body></html>