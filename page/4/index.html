<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#fff"><link rel="preload" href="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/fonts/Candyshop.otf" as="font" type="font/otf" crossorigin="anonymous"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.74" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=0.0.74"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.ico?v=0.0.74"><link rel="mask-icon" href="/safari-pinned-tab.svg?v=0.0.74" color="#fff"><link rel="manifest" href="/manifest.json"><meta name="keywords" content="いざよい,everbrez"><link rel="alternate" href="/atom.xml" title="Hi, いざよい" type="application/atom+xml"><meta name="description" content="If I could be the hero"><meta property="og:type" content="website"><meta property="og:title" content="Hi, いざよい"><meta property="og:url" content="https://everbrez.github.io/page/4/index.html"><meta property="og:site_name" content="Hi, いざよい"><meta property="og:description" content="If I could be the hero"><meta property="og:locale"><meta property="article:author" content="everbrez"><meta property="article:tag" content="いざよい,everbrez"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"",scheme:"Pisces",version:"0.0.74",sidebar:{position:"right",display:"always",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"4/18/2021 18:00:00",site:{title:"",subtitle:"",author:""},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!1,appID:"",appKey:""},favicon:{visibilitychange:!0,narmal:"/assets/favicon.ico",hidden:"/assets/favicon.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/disqusjs@1.2.2/dist/disqus.js"></script><link rel="canonical" href="https://everbrez.github.io/page/4/"><title>Hi, いざよい</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" class="theme-darling"><div class="container sidebar-position-right page-home"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fas fa-meteor"></i><br>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fas fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="menu-item-icon fas fa-heartbeat"></i><br>关于我</a></li><li class="menu-item search"><form class="search-form"><input name="keyword" type="text" class="search-input" placeholder="站内搜索"> <button type="submit" class="search-submit"><i class="fas fa-search"></i></button></form></li></ul></nav><div class="site-brand-wrapper"><div class="site-brand-bg"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/header-gyx-s.webp" type="image/webp" media="(max-width: 500px)"><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/header-gyx-s.png" type="image/png" media="(max-width: 500px)"><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/header-gyx.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/header-gyx.png"></picture></div><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate-stroke" class="animate"><span><svg><use xlink:href="#strokeH"></use></svg> </span><span><svg><use xlink:href="#strokei"></use></svg> </span><span><svg><use xlink:href="#stroke,"></use></svg> </span><span><svg><use xlink:href="#stroke "></use></svg> </span><span><svg><use xlink:href="#strokeい"></use></svg> </span><span><svg><use xlink:href="#strokeざ"></use></svg> </span><span><svg><use xlink:href="#strokeよ"></use></svg> </span><span><svg><use xlink:href="#strokeい"></use></svg></span></div><div id="animate" class="animate"><span><svg><text id="strokeH">H</text></svg> </span><span><svg><text id="strokei">i</text></svg> </span><span><svg><text id="stroke,">,</text></svg> </span><span><svg><text id="stroke "></text></svg> </span><span><svg><text id="strokeい">い</text></svg> </span><span><svg><text id="strokeざ">ざ</text></svg> </span><span><svg><text id="strokeよ">よ</text></svg> </span><span><svg><text id="strokeい">い</text></svg></span></div><div id="guide" class="guide"><span>H</span><span>i</span><span>,</span><span> </span><span>い</span><span>ざ</span><span>よ</span><span>い</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/assets/images/avatar.webp" type="image/webp"><img loading="lazy" class="site-master-avatar scaleup" itemprop="image" src="/assets/images/avatar.jpg" alt=""></picture><h2 class="site-master-description scaleup" itemprop="description">If I could be the hero</h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">22</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NetWork/" itemprop="url" rel="index"><span itemprop="name">NetWork</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-23-os/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-23-os/" itemprop="url">os</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T00:00:00+00:00">2019-02-22</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">2059</span></span></div></header><div class="post-body" itemprop="articleBody"><p>os</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-23-os/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">22</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/NetWork/" itemprop="url" rel="index"><span itemprop="name">NetWork</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-23-websocket/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-23-websocket/" itemprop="url">WebSocket</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T00:00:00+00:00">2019-02-22</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">642</span></span></div></header><div class="post-body" itemprop="articleBody"><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议，是一个<strong>持久化</strong>的协议</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-23-websocket/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">20</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-20-nodejs/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-20-nodejs/" itemprop="url">Nodejs</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T00:00:00+00:00">2019-02-20</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">804</span></span></div></header><div class="post-body" itemprop="articleBody"><p>严格来说，一切动作都是事件，这就是事件驱动的思想</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-20-nodejs/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-GC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-GC/" itemprop="url">GC</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">649</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="V8引擎垃圾回收算法"><a href="#V8引擎垃圾回收算法" class="headerlink" title="V8引擎垃圾回收算法"></a>V8引擎垃圾回收算法</h1><p>分代式垃圾回收</p><ul><li>新生代：新生代中的对象为存活时间较短的对象</li><li>老生代：老生代中的对象为存活时间和数量较多的对象</li></ul><p>按照对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存实行更高效的算法</p><p>scavenge 算法（具体实现采用了Cheney算法）—》通过牺牲空间换时间适合生命周期短的新生代</p><p>Cheney算法是采用复制方式实现的垃圾回收算法，它将堆内存一分为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用中的成为From空间，处于闲置状态的空间成为To空间。</p><p>分配对象时，首先从From空间进行分配，当开始垃圾回收时候，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活的对象占用的空间将会被释放。完成复制之后，From和To角色互换</p><ul><li>新生代中的对象是否已经经历多次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ul><h2 id="在老生代中，以下情况会先启动标记清除算法："><a href="#在老生代中，以下情况会先启动标记清除算法：" class="headerlink" title="在老生代中，以下情况会先启动标记清除算法："></a>在老生代中，以下情况会先启动标记清除算法：</h2><ul><li>空间中对象超过一定限制</li><li>空间不够新生代对象转移到老生代中</li><li>某一个空间没有分块的时候</li></ul><h3 id="Mark-Sweep-amp-Mark-Compact"><a href="#Mark-Sweep-amp-Mark-Compact" class="headerlink" title="Mark-Sweep &amp; Mark-Compact"></a>Mark-Sweep &amp; Mark-Compact</h3><p>标记清除算法和标记压缩算法<br><code>Mark-Sweep</code>在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。<br>而清除之后出现内存的不连续，需要<code>Mark-Compact</code>进行整理</p><h3 id="增量标志"><a href="#增量标志" class="headerlink" title="增量标志"></a>增量标志</h3><p>垃圾回收的三种算法都需要将应用逻辑暂停下来，代执行完垃圾收集后再恢复执行应用逻辑，成为“全停顿”，带来体验的影响。</p><p>V8从标记阶段入手，将一口气停顿完成的动作改为增量标记。就是拆分为许多小的“步进”，每做完一“步进”，就让JavaScript应用逻辑执行一小会。交替直至完成。</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-GC/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Cache/" itemprop="url" rel="index"><span itemprop="name">Cache</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-cache/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-cache/" itemprop="url">Cache</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1925</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存具有优先级，根据其位置不同可分为下面。浏览器查找缓存的时候，依次根据优先级查找，如果都没有找到的时候，便会发起网络请求：</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li><li>network request</li></ol><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p><code>navigation.serviceWorker</code></p><p>Service Worker 是运行在浏览器的另一个独立线程</p><ul><li>传输协议必须是HTTPS（Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。）</li></ul><p>步骤：</p><ol><li>注册Server Worker</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">&#x27;worker.js&#x27;</span>).then(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>)).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li>监听<code>install</code>事件，缓存需要的文件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&#x27;my-cache&#x27;</span>).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;./index.js&#x27;</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截请求</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    cache.match(e.request).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (responese) &#123;</span><br><span class="line">        <span class="keyword">return</span> responese</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>在下次用户访问的时候就可以通过拦截请求的方式查询是否有缓存，如果存在缓存就使用缓存，如果没有就去请求数据</li><li>当Service Worker没有命中缓存的时候，会根据缓存优先度去查找数据。（当时无论是从Memory Disk中还是从网络中获取数据，浏览器都是显示是从Service Worker中获取的）</li></ol><h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>Memory Cache 就是内存中的缓存，它会随着进程的释放而释放。持续时间很短，存储量少</p><h2 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h2><p>Disk Cache 是存储在硬盘中的缓存，它较于Memory Cache具有时效性长（根据http返回的header设置时间），容量大的特点。</p><h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><p>Push Cache 是HTTP/2.0 的内容 ，当上面三种缓存都没命中的时候，才会触发这种缓存。</p><p>它的缓存时间很短，只在一个会话（session）中存在，一点会话结束就会被释放</p><p><a href="https://link.juejin.im/?target=https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/">HTTP/2 push is tougher than I thought</a></p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1><p>通常浏览器的缓存策略分为两种：协商缓存 和 强缓存</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存代表在缓存期间不需要请求，直接返回200</p><ul><li>Expires：HTTP/1.0产物，表示资源在某个时间后过期，并且受制于系统时间</li><li>Cache-Control：max-age:30 优先级高于Expires，表示该资源在30s后过期，需要再次请求。</li></ul><p>Cache-Control常见指令：</p><ul><li>public 响应可以同时被客户端和代理服务器缓存</li><li>private 相应只能被客户端缓存</li><li>max-age 缓存存活时间</li><li>s-max-age 覆盖max-age，作用一样，只在代理服务器生效</li><li>no-store 不缓存任何响应</li><li>no-cache 资源被缓存，但是立即失效，下次请求验证资源是否过期</li><li>max-stale ns内，即使缓存过期，也使用该缓存</li><li>max-fresh 希望在30s内获取最新响应</li></ul><blockquote><p>max-age=0, no-cache 等同 must-revalidate</p></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>如果缓存过期了，就需要发起请求验证资源是否过期。如果资源没有改变，服务器端返回304表示无更新，并更新缓存有效期</p><ul><li>Last-Modified</li><li>ETag</li></ul><h3 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h3><p>Last-Modified 表示本地文件最后的修改日期，其中<code>If-Modified-Since</code>会将<code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，如果有就将新的资源发送回来，如果没有就返回304</p><p>弊端：</p><ul><li>如果在本地打开了文件，即使没有修改也会造成<code>Last-Modified</code>的值被修改，从而导致服务端不能命中缓存导致发送相同资源</li><li>因为<code>Last-Modified</code>只能以秒计算，所以如果在1s内修改了文件，服务端会认为资源还是有效的，从而不能发送正确的资源</li></ul><h3 id="ETag-和-If-None-Match"><a href="#ETag-和-If-None-Match" class="headerlink" title="ETag 和 If-None-Match"></a>ETag 和 If-None-Match</h3><p>ETag类似于文件指纹，优先级高于<code>Last-Modified</code><br><code>If-None-Match</code>会将当前的ETag发送给服务端，如果有变动就发送新的资源回来</p><h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p>语法：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>W/&quot;&lt;ETag value&gt;&quot;</span><br></pre></td></tr></table></figure><ul><li>W 为可选值（大小写敏感），表示使用弱验证器</li><li><etag value>表示位于双引号的字符串。<strong>没有明确指定生成ETag值的方法</strong>，通常使用内容的hash以及最后修改时间的时间戳的hash值，或简单地使用版本号。</etag></li></ul><blockquote><p>Apache将文件索引节（inode），大小（size）和最后修改时间作为输入求值得到<br>在3.23版本后移除inode，只留下大小和时间戳</p></blockquote><ol><li>ETag可以避免“空中碰撞”：</li></ol><p>如果正在编辑文章的时候，当前wiki内容被hash，然后将ETag内容放入响应中（服务端）</p><p>将更改保存到wiki页面的时候（发布数据），POST请求可以附带含有ETag值的<code>If-Match</code>来检查是否最新版本。</p><p>如果不是最新版本，意味着文档已经被编辑，抛出412提示条件判断错误。</p><ol start="2"><li>ETag可以缓存未更改的资源</li></ol><p>如果用户再次访问已经过期的含有ETag资源的时候，客户端就会发送一个含有<code>If-None-Match</code>的字段到服务端</p><p>服务端判断两个ETag的值是否一致，如果一致则返回304状态码，告诉客户端缓存可用</p><h4 id="如果服务端同时设置了ETag和Last-Modified，那么这两个谁的优先度高？"><a href="#如果服务端同时设置了ETag和Last-Modified，那么这两个谁的优先度高？" class="headerlink" title="如果服务端同时设置了ETag和Last-Modified，那么这两个谁的优先度高？"></a>如果服务端同时设置了ETag和Last-Modified，那么这两个谁的优先度高？</h4><p>一般来说，ETag的优先度会比Last-Modified优先度高</p><blockquote><p>from <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7232.txt">https://www.rfc-editor.org/rfc/rfc7232.txt</a>, RFC 7232:<br>A recipient MUST ignore If-Modified-Since if the request contains an<br>If-None-Match header field; the condition in If-None-Match is<br>considered to be a more accurate replacement for the condition in<br>If-Modified-Since, and the two are only combined for the sake of<br>interoperating with older intermediaries that might not implement<br>If-None-Match.<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25322053/what-if-both-if-modified-since-and-if-none-match-are-present-in-http-headers?rq=1">What if both If-Modified-Since and If-None-Match are present in HTTP headers</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/824152/what-takes-precedence-the-etag-or-last-modified-http-header">What takes precedence: the ETag or Last-Modified HTTP header?</a></p></blockquote><h4 id="既然有了-ETag，那么-Last-Modified-还有存在的必要吗？"><a href="#既然有了-ETag，那么-Last-Modified-还有存在的必要吗？" class="headerlink" title="既然有了 ETag，那么 Last-Modified 还有存在的必要吗？"></a>既然有了 ETag，那么 Last-Modified 还有存在的必要吗？</h4><p>有必要存在：</p><ol><li>兼容性考虑</li><li>ETag计算需要耗费性能，对于要求不高的资源可以使用<code>Last-Modified</code></li><li>ETag在分布式系统中，可能不同的系统产生不同的ETag，从而导致ETag不统一</li></ol><h2 id="vary"><a href="#vary" class="headerlink" title="vary"></a>vary</h2><p>这个是告知代理服务器在缓存文件的时候要区分<code>vary</code>字段里面的header，他会根据vary指定的字段不同而缓存不同的文件（比如一个是使用过gzip压缩过的文件，另外一个不是通过gzip压缩过的文件）</p><h3 id="没有缓存策略的情况"><a href="#没有缓存策略的情况" class="headerlink" title="没有缓存策略的情况"></a>没有缓存策略的情况</h3><p>如果没有缓存策略的情况下，浏览器会采用采用一个启发式算法：去响应头中的<code>Date</code>减去<code>Last-Modifiled</code>的值的10%作为缓存时间</p><h2 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h2><ol><li>通常HTML不缓存或者缓存时间很短，所以可以通过打包工具，对文件名进行处理，当文件改变的时候就会更改文件名，从而使其发起新的请求。设置其他缓存为一个很长的时间。</li><li>对于频繁变动的文件，可以设置<code>Cache-Control: no-cache</code>使浏览器每一次都验证资源的有效性，这样做虽然不能减少请求数量，但是可以减少数据的传输。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a target="_blank" rel="noopener" href="https://aotu.io/notes/2016/09/22/http-caching/?o2src=juejin&o2layout=compat">HTTP 缓存</a></p><p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#validating_cached_responses_with_etags">HTTP Cache(google-developer)</a></p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-cache/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-cross-origin/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-cross-origin/" itemprop="url">cross origin</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1204</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>如果协议、域名或者端口号有一个不同就是跨域。一般使用“<code>javascript:;</code>”以及”<code>about blank</code>“打开的页面会继承源。但是<code>data：</code>协议的不继承。<br>在IE中，端口号不在同源策略中。两个高度互信的范围不遵循授权范围。</p><p>可以使用<code>document.domain</code>修改</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>主要是用来防止CSRF（跨站请求伪造Cross Site Request Forgery）攻击的</p><p>没有同源策略的情况下，A网站可以被其他来源的内容Ajax访问到内容。如果保留着登录态，其他来源的Ajax就可以访问到你的全部信息</p><p>请求跨域了，但是请求是成功发送了。只是浏览器将响应结果拦截了。</p><p>1）无法读取不同源的 Cookie、LocalStorage 和 IndexDB 。<br>2）无法获得不同源的DOM 。<br>3）不能向不同源的服务器发送ajax请求。<br>4）websocket 不受影响</p><p><code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code></p><h2 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h2><p>根据使用场景差异分为：</p><ol><li>同一主域：使用document.domain</li><li>不同主域：使用window.name/ Location.hash/ JSONP / CORS/ postmessage / 图片img/ web socket/ 反向代理</li></ol><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>适用于二级域名相同的情况，只要设置两个页面中的<code>document.domain</code>相同就可以实现跨域请求<br>例如 mail.qq.com qq.com<br>store.google.com google.com</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>利用script标签，GET请求，callback<br>淘宝和天猫cookie的传递，是利用JSONP来实现的（天猫通过访问淘宝的一个JSONP服务器，然后返回之后将cookie改写）</p><p>原理：</p><ol><li>前端通过script标签进行跨域</li><li>将前端的方法通过参数来传递到服务器（例如callback），然后服务器注入参数之后返回，实现服务器与客户端的通信</li><li>只支持GET方法，只能使用全局方法（可以解决）</li></ol><p>注意事项：<br>如果由参数，需要进行encodeURLComponent()</p><p>优点：兼容性好，URL限制参数，错误处理机制不好，预料外返回难以处理。script标签的onerror</p><h3 id="CORS跨域资源共享-根本解决方法"><a href="#CORS跨域资源共享-根本解决方法" class="headerlink" title="CORS跨域资源共享(根本解决方法)"></a>CORS跨域资源共享(根本解决方法)</h3><p>需要后端浏览器和后端同时支持，<br>服务端设置 <code>Access-Control-Allow-Origin</code></p><ul><li>简单请求<ul><li>使用以下请求：<code>POST</code>、<code>HEAD</code>、<code>GET</code></li><li>首部集合：Accept、Accept-Language Content-Language</li><li><code>Content-Type</code>为以下：<code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code></li><li>请求中的XMLHttpRequestUpload对象没有注册任何事件监听器</li><li>请求中没有使用ReadableStream对象</li></ul></li><li>复杂请求<ul><li>不满足上面的请求即为复杂请求</li></ul></li></ul><p>对于复杂请求，首先会触发一个<code>OPTIONS</code>预检请求，通过这个请求来知道服务器是否允许跨域请求。</p><p>服务器会返回一个HTTP字段<code>Acess-Control-Allow-Origin</code>，表明该资源可以被设置的外域访问</p><p>预检请求通过<code>OPTIONS</code>方法发起一个请求到服务器，以获知服务器是否允许该实际请求。（可以避免跨域请求对服务器的用户数据产生未预期的影响），请求同时携带了两个首部字段</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Request-Method</span><span class="punctuation">: </span>POST</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span><span class="punctuation">: </span>...(实际请求携带的自定义首部字段)</span><br></pre></td></tr></table></figure><p>其中xhr中请求要设置<code>withCredentials=true</code>才能携带cookie</p><p>缺点：非简单请求需要多一次请求，需要服务端设置相应，兼容性问题</p><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">  <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">targetWindow.postMessage(data, targetOrigin) <span class="comment">// targetOrigin类似（https://google.com）</span></span><br></pre></td></tr></table></figure><p>targetWindow:</p><ul><li>window.open</li><li>window.opener</li><li>HTMLFrameElement.contentWindow</li><li>window.parent</li><li>widnow.frames</li></ul><p>缺点，兼容性不好，ie9只对iframe使用，不能对其他tab使用<br>（优酷）</p><h3 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h3><p>打开一个隐藏的iframe，src到跨域地址，iframe通过改变hash来通讯<br>优点：双向通讯<br>缺点：通过url，不够安全，大小限制，需要通过onhashchange事件，兼容性问题</p><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>原理：一个window生命周期内，window name属性共享，注意XSS注入</p><p>过程：</p><ol><li>a页面打开b页面iframe</li><li>b加载完之后将数据写进去window.name，然后跳转到和a同域的代理页面（同域才能操作）</li><li>读取iframe.contentWindow.name得到跨域data</li></ol><p>优点：传输的数据量大：2M，支持性好，支持GET和POST</p><p>缺点： 需要请求一次Proxy页面，Content Security Policy（CSP)，内容安全策略（HTTP设置），X-Frame-Options设置</p><h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>服务端没有同源限制</p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p>ws不实行同源政策</p><h3 id="图片Ping"><a href="#图片Ping" class="headerlink" title="图片Ping"></a>图片Ping</h3><p>只能单向，通常用来上报一些数据</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-cross-origin/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-new-technology/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-new-technology/" itemprop="url">new technology</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">14</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><h1 id="WebAssembly-WebComponent"><a href="#WebAssembly-WebComponent" class="headerlink" title="WebAssembly / WebComponent"></a>WebAssembly / WebComponent</h1><h1 id="CSS-in-JS-JSS"><a href="#CSS-in-JS-JSS" class="headerlink" title="CSS-in-JS / JSS"></a>CSS-in-JS / JSS</h1><h1 id="typeScript"><a href="#typeScript" class="headerlink" title="typeScript"></a>typeScript</h1><h1 id="parcel-VS-webpack"><a href="#parcel-VS-webpack" class="headerlink" title="parcel VS webpack"></a>parcel VS webpack</h1><h1 id="yarn-VS-npm"><a href="#yarn-VS-npm" class="headerlink" title="yarn VS npm"></a>yarn VS npm</h1><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-new-technology/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-performance/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-performance/" itemprop="url">performance</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1509</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h1><ol><li>减少http请求<ol><li>图片使用sprite，使用图片地图（map/area），使用伪协议（data://），合并css和JavaScript文件（但是抽离公共部分），按需加载</li><li>缓存：设置expires、cache-control、Etag、CDN等缓存，解决文件更新问题（文件名改变），使用外部css和JavaScript文件</li></ol></li><li>加快http请求<ol><li>使用压缩gzip选项</li><li>使用HTTP/2 或者 HTTP/3（多路复用，UDP）</li><li>预加载、DNS预解析</li><li>压缩JavaScript和css文件，抽离公共部分</li><li>减少重定向</li><li>无阻塞加载脚本</li></ol></li><li>客户端<ol><li>scirpt标签放在body最后，link放在head（前面），script会阻塞，它可以使用document.write来改写后面的，所以脚本必须顺序执行（可以使用无阻塞并行下载async、或延迟下载defer==保证顺序执行）</li><li>JavaScript运行优化（如动画使用requestAnimationFrame），利用引擎优化性能</li><li>预渲染</li><li>css解析性能</li><li>渲染性能</li><li>onload后加载（拆分代码）</li></ol></li></ol><h1 id="JS性能优化"><a href="#JS性能优化" class="headerlink" title="JS性能优化"></a>JS性能优化</h1><p>在V8引擎下，引入了<code>TurboFan</code>编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的<code>Machine Code</code></p><p>在这一过程中，JS会首先被解析为AST（抽象语法树），解析过程略慢。</p><p><picture><source srcset="/assets/images/v8.webp" type="image/webp"><img loading="lazy" src="/assets/images/v8.png" alt="v8"></picture></p><p>Ignition会将AST转化成Bytecode，TurboFan负责编译出优化后的Machine Code，在执行效率上，Machine Code优于 Bytecode</p><ol><li>对于函数，避免声明嵌套函数（类也是函数），这样会造成函数的重复解析</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译为 Machine Code的情况：</p><ol><li>如果一个函数被多次调用，并且参数一直传入同一个类型，那么V8就会认为该段代码可以编译成Machine Code。因为Machine Code 固定了类型，不需要再执行很多判断逻辑了。如果此时传入的参数类型发生改变，那么Machine Code就会被DeOptimized为Bytecode。DeOptimized次数较少就应该要保证传入的类型一致</li></ol><p>另外编译器会对函数进行 Lazy-Compile（预解析），当函数没有执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。而对于马上调用的函数来说，预解析其实是多余的。其实给函数套上括号就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h1><p>计算图片大小：</p><p>对于一个<code>100px * 100px</code>的图片，图像中有<code>10000px</code>的点，每一个<code>px</code>有<code>4</code>个通道（<code>rgba</code>），每一个通道<code>1</code>个字节（<code>1byte = 8bit</code>），所以该图片大小为 <code>10000 * 4 / 1024</code></p><h2 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h2><ol><li>不用图片</li><li>移动端适配，裁剪加载</li><li>小图使用base64</li><li>使用雪碧图</li><li>选择正确的图片格式：<ol><li>webp</li><li>小图使用png</li><li>大图使用jpeg</li></ol></li><li>懒加载</li></ol><h1 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure><h1 id="函数节流和防抖"><a href="#函数节流和防抖" class="headerlink" title="函数节流和防抖"></a>函数节流和防抖</h1><h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载</p><h1 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>首先将图片上的src属性设置为loading的图片，然后在图片的data-src上设置真实的src地址。<br>首先加载前n个图片，然后记录最后加载到的数据索引<br>监控window的滚动事件，如果索引所在的地方距离可视范围一定距离的时候，执行加载程序。可以使用函数节流和防抖的方式。</p><p>另一种方法， IntersectionObserver 方法（优先级低）</p><p>第三种方法，对img都订阅事件，当滚动结束的时候才开始加载（从视口开始加载）节流，当出现在视口才开始加载</p><p>对于页面：import、ajax</p><h1 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h1><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限<br>可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。</p><h1 id="编写高效的JavaScript"><a href="#编写高效的JavaScript" class="headerlink" title="编写高效的JavaScript"></a>编写高效的JavaScript</h1><ol><li><a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/5">执行上下文</a>，执行上下文中变量标识符在作用域链中位置越深，查找和访问它所需要的时间就越长。所以使用局部变量是JavaScript读写最快的标识符</li><li>使用with会使作用域链加深，第二个使try-catch语句中的catch语句，其行为类似于with语句，也是在作用域链上增加了一个对象。该对象包含了由catch指定命名的异常对象</li><li>高效存储：从字面量中和局部变量中读取值的开销小，但是在对象中读取数据和数组开销大。所以在对象属性或数组属性存储为局部变量是一种好方法。</li><li>流控制：大量if/else之类出现的，按频率排序，也可以拆分成几个分支（二分查找），switch简化了多重判断的结构，提上了性能</li><li>循环：可以将变量从length变成0，若执行过长的循环可以考虑使用异步</li></ol><h1 id="简化CSS选择符"><a href="#简化CSS选择符" class="headerlink" title="简化CSS选择符"></a>简化CSS选择符</h1><p>css选择符是从右边开始的</p><ol><li>避免了通配选择符</li><li>不要限定ID选择符，页面中一个ID只能对应一个对象，如：<code>#id</code>而不是<code>li#id</code></li><li>不要限定类选择符，而是根据实际情况进行拓展</li><li>避免使用后代选择符，处理后代选择符开销是最高的。应该使用子选择符</li><li>避免使用标签-子选择符：如果像<code>#id &gt; li &gt; a</code>，这样基于标签的子选择符，那么应该使用一个类来关联每个标签元素。如果可以尽量使用类名。</li><li>不要试图编写长的选择符</li><li>依靠继承</li></ol><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-performance/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-react/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-react/" itemprop="url">react</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">2986</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p><picture><source srcset="/assets/images/mvc.webp" type="image/webp"><img loading="lazy" src="/assets/images/mvc.png" alt="MVC"></picture></p><p><a target="_blank" rel="noopener" href="https://github.com/livoras/blog/issues/11">MV*</a></p><p><code>model</code> 用来封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。(有操作数据的方法)</p><p><code>view</code> 视图，当模型发生变化的时候，视图相应得到刷新自己的机会</p><p><code>controller</code> 定义用户界面对用户输入的相应方式，起到不同层面的组织作用，用于控制应用程序的流程，它处理用户行为和数据<code>model</code>的改变。它的职责为进行Model和View之间的协作（路由、输入预处理等）的应用逻辑（application logic）。</p><p>其中：<code>view</code>和<code>model</code>之间是观察者模式，<code>view</code>观察<code>model</code>，实现在<code>model</code>上注册，以便<code>view</code>可以了解在数据<code>model</code>上发生的改变<br><code>view</code>和<code>controller</code>是策略模式，<code>view</code>可以使用<code>controller</code>的方法</p><p>Controller和View都依赖Model层</p><h2 id="调用关系："><a href="#调用关系：" class="headerlink" title="调用关系："></a>调用关系：</h2><p>用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller会对来自View数据进行预处理、决定调用哪个Model的接口；然后由Model执行相关的业务逻辑；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。</p><p>需要注意的地方：</p><ol><li>View是把控制权交移给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。</li><li>Controller操作Model，Model执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。</li><li>View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。</li></ol><p>缺点：</p><ol><li>View无法组件化。View是强依赖特定的Model的</li></ol><h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>Model View Presenter 为MVC的一种衍生模式</p><p>切入点：解决<code>controller</code>和<code>view</code>的捆绑关系，将其进行改造，使<code>view</code>不仅拥有UI组件的结构，还拥有处理用户事件的能力。此时<code>view</code>不能调用<code>model</code>的方法，所以只能让<code>presenter</code>取更新<code>model</code>，在通过观察者模式更新<code>view</code>。<br>相比与传统MVC，解耦了<code>model</code>和<code>view</code>，完全分离视图和模型，使职责划分更加清晰。可以将<code>view</code>抽象出来做成组件。</p><p>（<code>controller</code>可以在<code>view</code>中复用）。</p><p>应用逻辑主要集中在<code>presenter</code>这一层中。缺点：手动更新</p><h2 id="调用关系"><a href="#调用关系" class="headerlink" title="调用关系"></a>调用关系</h2><p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，<strong>通过View提供的接口更新界面</strong>。</p><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>最重要的使数据绑定，data-binding。</p><p>view和model不知道彼此的存在，同MVP一样，将view和model清晰地分离开，如果viewmodel的属性值改变了，这些新值通过数据绑定自动传递给view，反过来，viewmodel会暴露model中数据和特定状态给view。</p><p>此时的model是单纯的数据，不包含对数据的操作</p><p>Vue双向数据绑定：通过Object.defineProperty来实现绑定</p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/593021272f301e0058273468#heading-9">vue的双向数据绑定</a></p><h1 id="flux"><a href="#flux" class="headerlink" title="flux"></a>flux</h1><p>Flux将一个应用分成四个组成部分：</p><ul><li>View：视图</li><li>Action：一个对象，视图发出的信息，包含一个type以及数据</li><li>Dispatcher：接收Actions，执行回调函数</li><li>Store：数据层，用来存放应用状态，提醒Views更新页面</li></ul><p>Predictable<br>特点：单项数据流动</p><h2 id="control-view"><a href="#control-view" class="headerlink" title="control view"></a>control view</h2><p>用来保存状态，监听store的变化，然后数据转发给子组件。<br>子组件不包含所有的状态，为纯组件。</p><h2 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h2><p>将action派发到store，dispatcher只有一个，而且是全局的。</p><h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><h1 id="router-control"><a href="#router-control" class="headerlink" title="router control"></a>router control</h1><h1 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h1><h1 id="communication"><a href="#communication" class="headerlink" title="communication"></a>communication</h1><h1 id="HOC-amp-mixins"><a href="#HOC-amp-mixins" class="headerlink" title="HOC &amp; mixins"></a>HOC &amp; mixins</h1><h1 id="event"><a href="#event" class="headerlink" title="event"></a>event</h1><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="element-amp-component"><a href="#element-amp-component" class="headerlink" title="element &amp; component"></a>element &amp; component</h2><p>element是由component生成的，element是一个对象，component是一个构造函数。<br>element是immutable（不能改变）的，一旦创建了就不能更改element的children、attributes等属性。</p><h2 id="state-amp-props"><a href="#state-amp-props" class="headerlink" title="state &amp; props"></a>state &amp; props</h2><p>props只能读，不能更改。所有的React Component 必须像纯函数那样对待他们的props</p><p><code>this.props</code> 与 <code>this.state</code> 可能被异步更新，所以不能依靠他们来计算下一个<code>state</code>，要使用回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;<span class="attr">counter</span>: state.counter + props.counter&#125;))</span><br></pre></td></tr></table></figure><h2 id="dataflow"><a href="#dataflow" class="headerlink" title="dataflow"></a>dataflow</h2><p>top-down/ unidirectional 数据流<br>state只能被特定的组件所拥有，所有的state数据更新只能影响这个组件树下层的组件</p><h2 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h2><p>React的event使用驼峰写法，而不是全部小写<br>将一个函数传给下一个组件的事件，而不是字符串<br>（不能return false来阻止默认行为，只能使用preventDefault来）<br>React的事件是一个合成事件。所以不需要担心浏览器兼容性</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2016/08/25/react-key/">react-key</a></p><p>注意key相同可能引发错误，使用index作为key也可能引发错误。</p><p>以下三个条件满足的情况下中可以使用index作为key：</p><ul><li>list中的数据不会改变（即不会重新计算）</li><li>list不会过滤或者重新保存（如排序）</li><li>list中item没有唯一的id</li></ul><h3 id="diff算法·"><a href="#diff算法·" class="headerlink" title="diff算法·"></a>diff算法·</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/20346379">diff-algorithm</a></p><p>基于假设：</p><ol><li>两个不同type的element会生成不同的树</li><li>可以增加一个key prop来指定哪个element是不变的</li></ol><h3 id="virtual-dom"><a href="#virtual-dom" class="headerlink" title="virtual-dom"></a>virtual-dom</h3><p>尝试去最小化回流/重绘步骤，从而在大型且复杂的项目中得到更好的性能</p><p><code>virtual-dom ---&gt; fiber</code></p><p><a target="_blank" rel="noopener" href="https://github.com/livoras/blog/issues/13">virtual-dom</a></p><h4 id="stack-reconciler"><a href="#stack-reconciler" class="headerlink" title="stack-reconciler"></a>stack-reconciler</h4><h4 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h4><p><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/dive-into-react-fiber/">完全理解React Fiber</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ab7b3a2f265da2378403e57">React Fiber</a></p><p><a target="_blank" rel="noopener" href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p><p><a target="_blank" rel="noopener" href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7">the-how-and-why-on-reacts-usage-of-linked-list-in-fiber</a></p><h4 id="Reconciliation"><a href="#Reconciliation" class="headerlink" title="Reconciliation"></a>Reconciliation</h4><h2 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h2><p><a target="_blank" rel="noopener" href="https://a11yproject.com/checklist.html">checklist</a></p><h2 id="Lazy-amp-Suspense"><a href="#Lazy-amp-Suspense" class="headerlink" title="Lazy &amp; Suspense"></a>Lazy &amp; Suspense</h2><p>lazy接收一个含有<code>import</code>语句的回调，这个回调返回一个promise，（promise中必须有一个包含组件default export）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Component = React.lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./component&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">      &lt;Component /&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      error: <span class="literal">false</span>,</span><br><span class="line">      msg: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      error: <span class="literal">true</span>,</span><br><span class="line">      msg: error.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidCatch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, msg &#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">      &#123;error ? <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>error: &#123;msg&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="built_in">this</span>.props.children&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Error boundaries 不捕获下面的错误</p><ul><li>event handle</li><li>异步代码</li><li>服务器端渲染</li><li>Error boundaries 自己抛出的错误</li></ul><p>只有class组件才有error boundaries，与catch工作原理类似</p><p>在React 16 之后， 如果errors没有被catch，那么会把整个react组件树卸载。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><code>const MyContext = React.createContext(defaultValue)</code><br><code>defaultValue</code>只有在一个组件上方没有任何的<code>provider</code>的时候使用。</p><h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context.Provider value=&#123;<span class="comment">/* some value */</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>其中上方的value一般不使用字面量对象，一般使用this.state。因为如果是使用字面量对象，每次rerender的时候就会重新创建一个对象</p><h3 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h3><h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p>ref 不是props的属性，如果需要实现穿越组件传递ref，需要使用下面的api</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">React.forwardRef(<span class="function"><span class="keyword">function</span>(<span class="params">props, ref</span>) </span>&#123;...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">logProps</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="built_in">this</span>.props</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.forwardRef</code>接收一个render函数，这个函数接收两个props、ref</p><p>使用<code>React.createRef</code>不能使用在函数组件上，因为函数组件没有实例。</p><h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>与复合组件区别：<a target="_blank" rel="noopener" href="https://github.com/penouc/blog/issues/7">复合组件</a></p><p>一般而言，高阶组件是一个接收一个组件并且返回另外一个组件的函数</p><p>主要的作用是让不同组件之间共用逻辑</p><p>通常，高阶组件是一个纯函数，没有副作用</p><p>注意不要更改原组件</p><p>注意配置<code>displayName</code></p><p>不要将高阶组件放在<code>render</code>函数里面，performance以及内部state会消失（React会认为他们是不同的组件）</p><p>注意key以及ref的传递</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logProps</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... some method</span></span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; extraProps, ...passThroughProps &#125; = <span class="built_in">this</span>.props</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent injectProp=&#123;injectProp&#125; &#123;...passThroughProps&#125; /&gt; <span class="comment">//传递props以及插入props</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与mixin区别"><a href="#与mixin区别" class="headerlink" title="与mixin区别"></a>与mixin区别</h3><p><a target="_blank" rel="noopener" href="https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">mixins-considered-harmful</a></p><p>mixin是通过使用<code>Object.defineProperty</code>来实现多个组件之间方法的共用。<br>问题：</p><ol><li>破坏了原有组件的封装，不能改变state，或者将state提升的时候很麻烦</li><li>命名冲突，mixin很难去取出或者移除</li><li>增加复杂性：增加越来越多的mixin的时候，引入越来越多的方法，造成代码逻辑复杂，不易维护。</li></ol><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ol><li>HOC不要在render定义</li><li>使用data-，代替bind来传参数</li><li>注意移除event Listener</li><li>使用<code>production</code>版本</li><li>使用<code>shouldComponentUpdate</code></li><li>key</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// PureComponent封装了shouldComponentUpdate所需要的逻辑，对props和state进行浅比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><p>因为jsx解释出来是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">  <span class="number">233</span></span><br><span class="line">  &#123;value&#125;</span><br><span class="line">  &lt;Foo /&gt;</span><br><span class="line">  &lt;&gt;&lt;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">&#x27;div&#x27;</span>, </span><br><span class="line">&#123;<span class="attr">id</span>: <span class="string">&#x27;2&#x27;</span>&#125;, </span><br><span class="line"><span class="string">&#x27;233&#x27;</span>, </span><br><span class="line">value, </span><br><span class="line">React.createElement(Foo, <span class="literal">null</span>), React.createElement(React.Fragment, <span class="literal">null</span>))</span><br></pre></td></tr></table></figure><p>所以要在作用域内引入<code>React</code>才能正常工作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价</span></span><br><span class="line">&lt;MyComponent message=<span class="string">&quot;&amp;lt;3&quot;</span> /&gt;</span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">&#x27;&lt;3&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>children以及直接使用引号的html是没有转义的，因此可以像写HTML那样使用</p><p><code>false</code>，<code>null</code>，<code>undefined</code>，<code>true</code>会被忽略</p><h3 id="Protals"><a href="#Protals" class="headerlink" title="Protals"></a>Protals</h3><p>React可以在render中将element挂载在其他的节点下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ReactDOM.createPortal(<span class="built_in">this</span>.props.children, domNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个API可以正常使用Context之类的功能，因为它作为一个portal存在于React tree中，（无论它处于哪个DOM tree中）</p><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;&#123;count&#125;&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook:</p><ol><li>很难在组件之间重用一个有状态的逻辑（wrapper hell），不需要改变组件之间的关系重用逻辑</li><li>复杂组件很难被理解</li><li>兼容性</li></ol><h3 id="state-hook"><a href="#state-hook" class="headerlink" title="state hook"></a>state hook</h3><p>如果在要给render中多次调用useState，React会以相同的顺序调用他们<br>Hook就是一个钩子能够让你hook进去React函数组件的state和lifecycle（Hook不能在class中工作）</p><h3 id="effect-hook"><a href="#effect-hook" class="headerlink" title="effect hook"></a>effect hook</h3><p>获取数据，订阅，或者修改DOM这种副作用的时候使用<br>React默认在render之后执行effects（包括第一次render）<br>useEffect可以return一个函数作为callback</p><p>这个方法可以告诉React在render完成之后应该干什么，返回的函数称为clearup，React在组件unmount的时候运行这个clearup函数（React都会运行effect之前的clearup函数）==》原因：<br>如果props改变了，那么就可能会出现bug</p><p>可以告诉React跳过这个effect，使用第二个参数（数组）。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useEffext(<span class="function">() =&gt;</span> <span class="built_in">document</span>.title = <span class="string">`click <span class="subst">$&#123;count&#125;</span> times`</span>, [count])</span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;<span class="comment">/*do something*/</span>&#125;, []) <span class="comment">//空数组说明这个sideEffect不依靠于state，所以不需要在re-render的时候更新</span></span><br></pre></td></tr></table></figure><h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><ol><li>不要再循环、条件或者嵌套函数中使用hook</li><li>只在React函数组件中使用</li></ol><p>React怎么识别出哪个state是哪个useState调用的？</p><p>React根据hook被调用的顺序来判断的。（因为每次render的时候他们的顺序都不会发生改变）</p><h1 id="前端路由的实现"><a href="#前端路由的实现" class="headerlink" title="前端路由的实现"></a>前端路由的实现</h1><ol><li>hash模式，通过改变hash，监听hashchange事件来进行页面跳转</li><li>history模式，通过使用history中的新功能：history.putState和history.replaceState来改变URL（通过History模式改变URL不会引起页面的刷新，只会更新浏览器的历史纪录。）如果用户点击后退按钮，会触发popState事件</li></ol><h1 id="Vue-和-React-的区别"><a href="#Vue-和-React-的区别" class="headerlink" title="Vue 和 React 的区别"></a>Vue 和 React 的区别</h1><ol><li>Vue修改状态要简单一点，React需要使用setState来改变状态，并且需要手动优化</li><li>React使用了JSX，完全可以通过JS来控制页面，更加的灵活。Vue使用了模板语法，相比于JSX来说没有那么灵活，但是可以脱离工具链，通过直接编写render函数就能够在浏览器中运行。</li></ol><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-react/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">17</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-17-storage/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, いざよい"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-17-storage/" itemprop="url">storage</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T00:00:00+00:00">2019-02-17</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">347</span></span></div></header><div class="post-body" itemprop="articleBody"><p>浏览器的储存主要包括：<code>cookie</code>，<code>localStorage</code>，<code>sessionStorage</code>，<code>indexDB</code></p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-17-storage/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/images/card.webp" type="image/webp"><img loading="lazy" class="site-author-image" itemprop="image" src="/images/card.jpg" alt=""></picture><p class="site-author-name" itemprop="name">everbrez</p><p class="site-description motion-element" itemprop="description">你能抓到我么？</p></div><div class="links-of-author motion-element"><span class="links-of-author-item scaleup"><a href="https://github.com/everbrez" target="_blank" title="GitHub"><i class="fab fa-github" style="color:#191717"><span>everbrez</span></i></a></span></div><div class="des-of-author"><div class="des-of-author-nav"><div class="des-of-author-title active" data-index="1">最喜欢的作品</div><div class="des-of-author-title" data-index="2">最喜欢的女孩子</div><div class="des-of-author-title" data-index="3">最喜欢的游戏</div></div><div class="des-of-author-panel"><div class="des-of-author-des active" data-index="1">路人女主的养成方法、我的青春恋爱物语果然有问题</div><div class="des-of-author-des" data-index="2">加藤惠</div><div class="des-of-author-des" data-index="3">Minecraft</div></div></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.png"></picture></div><div class="footer-inner"><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>© <span itemprop="copyrightYear">2021</span> Hi, いざよい. 由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动. Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.74. <a href="/sitemap.xml" target="_blank">站点地图</a>.</p><p>Made with <i class="fas fa-heart throb" style="color:#d43f57"></i> by <span class="author" itemprop="copyrightHolder">everbrez</span>.</p></div></footer><div class="back-to-top"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.png"></picture></div><canvas id="evanyou"></canvas></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.74"></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js")})</script></body></html>