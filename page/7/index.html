<!DOCTYPE html><html class="theme-next pisces" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#fff"><link rel="preload" href="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/fonts/Candyshop.otf" as="font" type="font/otf" crossorigin="anonymous"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=0.0.74" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png?v=0.0.74"><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon.ico?v=0.0.74"><link rel="mask-icon" href="/safari-pinned-tab.svg?v=0.0.74" color="#fff"><link rel="manifest" href="/manifest.json"><meta name="keywords" content="十六夜,everbrez"><link rel="alternate" href="/atom.xml" title="Hi, everbrez" type="application/atom+xml"><meta name="description" content="If I could be the hero"><meta property="og:type" content="website"><meta property="og:title" content="Hi, everbrez"><meta property="og:url" content="https://everbrez.github.io/page/7/index.html"><meta property="og:site_name" content="Hi, everbrez"><meta property="og:description" content="If I could be the hero"><meta property="og:locale"><meta property="article:author" content="everbrez"><meta property="article:tag" content="十六夜,everbrez"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"",scheme:"Pisces",version:"0.0.74",sidebar:{position:"right",display:"always",offset:52,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,tabs:!0,motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},since:"4/18/2021 18:00:00",site:{title:"",subtitle:"",author:""},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},leancloud:{enable:!1,appID:"",appKey:""},favicon:{visibilitychange:!0,narmal:"/assets/favicon.ico",hidden:"/assets/favicon.ico",show_text:"(/≧▽≦/)咦！又好了！",hide_text:"(●—●)喔哟，崩溃啦！"}}</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/disqusjs@1.2.2/dist/disqus.js"></script><link rel="canonical" href="https://everbrez.github.io/page/7/"><title>Hi, everbrez</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" class="theme-darling"><div class="container sidebar-position-right page-home"><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fas fa-meteor"></i><br>首页</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fas fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-关于我"><a href="/about/" rel="section"><i class="menu-item-icon fas fa-heartbeat"></i><br>关于我</a></li><li class="menu-item search"><form class="search-form"><input name="keyword" type="text" class="search-input" placeholder="站内搜索"> <button type="submit" class="search-submit"><i class="fas fa-search"></i></button></form></li></ul></nav><div class="site-brand-wrapper"><div class="site-brand-bg"><picture><source srcset="/assets/images/mainvisual2.jpeg" type="image/webp"><img style="transform:translateY(-300px)" loading="lazy" src="/assets/images/mainvisual2.jpeg"></picture></div><div class="site-meta"><div class="custom-logo-site-title"><div class="brand"><span class="logo-line-before"><i></i></span><div class="site-title"><div id="animate-stroke" class="animate"><span><svg><use xlink:href="#strokeH"></use></svg> </span><span><svg><use xlink:href="#strokei"></use></svg> </span><span><svg><use xlink:href="#stroke,"></use></svg> </span><span><svg><use xlink:href="#stroke "></use></svg> </span><span><svg><use xlink:href="#strokee"></use></svg> </span><span><svg><use xlink:href="#strokev"></use></svg> </span><span><svg><use xlink:href="#strokee"></use></svg> </span><span><svg><use xlink:href="#stroker"></use></svg> </span><span><svg><use xlink:href="#strokeb"></use></svg> </span><span><svg><use xlink:href="#stroker"></use></svg> </span><span><svg><use xlink:href="#strokee"></use></svg> </span><span><svg><use xlink:href="#strokez"></use></svg></span></div><div id="animate" class="animate"><span><svg><text id="strokeH">H</text></svg> </span><span><svg><text id="strokei">i</text></svg> </span><span><svg><text id="stroke,">,</text></svg> </span><span><svg><text id="stroke "></text></svg> </span><span><svg><text id="strokee">e</text></svg> </span><span><svg><text id="strokev">v</text></svg> </span><span><svg><text id="strokee">e</text></svg> </span><span><svg><text id="stroker">r</text></svg> </span><span><svg><text id="strokeb">b</text></svg> </span><span><svg><text id="stroker">r</text></svg> </span><span><svg><text id="strokee">e</text></svg> </span><span><svg><text id="strokez">z</text></svg></span></div><div id="guide" class="guide"><span>H</span><span>i</span><span>,</span><span> </span><span>e</span><span>v</span><span>e</span><span>r</span><span>b</span><span>r</span><span>e</span><span>z</span></div></div><span class="logo-line-after"><i></i></span></div></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><div class="site-master" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/assets/images/avatar.webp" type="image/webp"><img loading="lazy" class="site-master-avatar scaleup" itemprop="image" src="/assets/images/avatar.jpg" alt=""></picture><h2 class="site-master-description scaleup" itemprop="description">If I could be the hero</h2></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">05</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-05-you-don't-konw-JS/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, everbrez"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-05-you-don't-konw-JS/" itemprop="url">you don't kown js</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+00:00">2019-02-05</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">1216</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>传统的编译语言中，程序的源代码在执行之前必须经历三个步骤，统称为编译。</p><ul><li>分词/词法分析（Tokenizing/Lexing）<br>这个过程将字符串分解成有意义的代码块，成为词法单元（token）。如：var a = 2; 会被分解成 var,a,=,2,;。</li><li>解析，语法分析（parsing）<br>这个过程将词法单元流（数组）转换成一个由元素逐级嵌套代表程序语法的树，成为抽象语法树。（AST,Abstract Syntax Tree）。如：var a = 2;的抽象语法树可能有一个叫做VariableDeclaration的顶级节点，然后有一个Identifier（值为a）的子节点以及一个AssignmentExpression的子节点。AssignmentExpression里有包含NumericalLiteral（值为2）的子节点。</li><li>代码生成<br>这个过程将AST转化成可执行代码的过程（机器语言）。</li></ul><h3 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h3><p>JavaScript编译到运行需要以下程序进行：</p><ul><li>引擎：从头到尾负责整个JavaScript的编译与运行</li><li>编译器：负责词法分析与代码生成等工作</li><li>作用域：负责收集并维护所有声明的标识符（变量）所进行的一系列查询</li></ul><p>对于<code>var a = 2;</code></p><ol><li>首先编译器会询问作用域是否存在名叫a的变量存在于当前作用域，如果是，则忽略声明，继续编译，如果不是，则要求作用域在当前作用域声明一个名叫a的变量。</li><li>然后编译器会生成为引擎运行需要的代码，这些代码会用来执行<code>a = 2</code>的赋值操作。引擎在执行代码的时候，首先会询问当前作用域是否存在名为a的变量，如果存在，则对此变量进行操作，如果不是，就继续往上一级作用域查找，直到全局作用域。</li></ol><blockquote><p>如果在全局作用域也没有找到，（非严格模式下RHS方式会抛出会抛出一个Reference异常，LHS方式会在全局作用域返回一个新的名叫a的变量；严格模式下，二者都会返回一个Reference异常）</p></blockquote><p>总结：变量赋值执行两个操作，首先编译器会在当前作用域声明一个新的变量，然后引擎在执行的时候查找该变量。如果能够找到就对它进行赋值。</p><h3 id="LHS-与-RHS"><a href="#LHS-与-RHS" class="headerlink" title="LHS 与 RHS"></a>LHS 与 RHS</h3><blockquote><p>引擎查找变量有两种方式，一种为：LHS，另一种为RHS</p></blockquote><p>LHS与RHS的含义为赋值操作符的左侧与右侧，但是其真正含义为赋值操作的目标（LHS）与赋值操作的源头（value）（RHS）</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><blockquote><p>如果变量还没有声明（在所有作用域都无法查找到该变量），这两种行为是不一样的。</p></blockquote><p>如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b)；</span><br><span class="line">    c = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>当执行到<code>a + b</code>时，第一次对b进行RHS查询是无法查询到该变量的，就是说这是一个未声明的变量，所以引擎会抛出ReferenceError异常。<br>相较之下，<code>c = a</code>当引擎通过LHS查询c的时候，在顶层作用域（全局作用域）无法找到该变量，全局作用域就会创建一个名为c的变量并返回引擎。</p><blockquote><p>在严格模式下，通过LHS查询失败并不会返回一个新的变量，而是抛出ReferenceError异常。</p></blockquote><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>词法作用域就是定义在词法阶段的作用域,是由书写时函数声明的位置决定的。</p></blockquote><p>值得注意的是：JavaScript只有词法作用域，并没有动态作用域。这以为着下面的代码运行结果是3而不是2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    bar(); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>包括变量和函数在内的所有声明都会在任何代码执行之前被首先处理。<br>提升是提升到当前作用域的上方，而不是全局作用域的上方。</p><blockquote><p>函数声明会被提升，但是函数表达式不会被提升。<br>对于以下代码：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//TypeError 而不是ReferenceError</span></span><br><span class="line">bar(); <span class="comment">//ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>函数声明和变量声明都会被提升，但是函数声明会被优先提升。(即如果同时存在函数声明和变量声明，函数声明会覆盖变量声明)</p><h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><blockquote><p>当函数记住并访问所在词法作用域时，便产生了闭包,即使函数在当前词法作用域之外执行。</p></blockquote><p>简单的闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo();</span><br><span class="line">bar(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><ul><li>回调函数</li><li>模块</li></ul><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-05-you-don't-konw-JS/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">05</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-22-HTML5-web-api/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, everbrez"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-22-HTML5-web-api/" itemprop="url">H5 Web API</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+00:00">2019-02-05</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">27</span></span></div></header><div class="post-body" itemprop="articleBody"><p>H5 Web API</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-22-HTML5-web-api/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">05</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-05-ES6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, everbrez"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-05-ES6/" itemprop="url">ES6</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+00:00">2019-02-05</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">7124</span></span></div></header><div class="post-body" itemprop="articleBody"><p>es6一些语法</p><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-05-ES6/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-date"><div class="post-month">02月</div><div class="post-day">05</div></div><div class="post-badge"><span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a></span></div><div class="post-block"><link itemprop="mainEntityOfPage" href="https://everbrez.github.io/2019-02-05-javascirpt-fundamental/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content=""><meta itemprop="description" content=""><meta itemprop="image" content="/assets/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hi, everbrez"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link scaleup" href="/2019-02-05-javascirpt-fundamental/" itemprop="url">Javascript fundamental</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-05T00:00:00+00:00">2019-02-05</time> </span><span class="post-wordcount"><span class="post-meta-divider">•</span> <span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">字数统计</span> <span title="字数统计">7477</span></span></div></header><div class="post-body" itemprop="articleBody"><span id="more"></span><h1 id="javascript-中的基本类型"><a href="#javascript-中的基本类型" class="headerlink" title="javascript 中的基本类型"></a>javascript 中的基本类型</h1><ul><li>undefined</li><li>null</li><li>number</li><li>string</li><li>boolean</li><li>symbol</li><li>object</li></ul><blockquote><p>需要注意的地方</p></blockquote><ul><li>NaN属于number类型，且不等于自身，即</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>对于基本类型来说，如果使用字面量的方式，那么这个变量只是一个字面量，只有在需要的时候才会转化为对应的类型，即</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">11</span> <span class="comment">// 此时a 为字面量，不是number类型</span></span><br><span class="line">a.toString() <span class="comment">// 在需要的时候才会转化成相应类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便一提</span></span><br><span class="line"><span class="number">11.</span>toString() <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof">MDN</a></p><table><thead><tr><th align="left">Type</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left">Undefined</td><td align="left">“undefined”</td></tr><tr><td align="left">Null</td><td align="left">“object” (see below)</td></tr><tr><td align="left">Boolean</td><td align="left">“boolean”</td></tr><tr><td align="left">Number</td><td align="left">“number”</td></tr><tr><td align="left">String</td><td align="left">“string”</td></tr><tr><td align="left">Symbol (new in ECMAScript 2015)</td><td align="left">“symbol”</td></tr><tr><td align="left">Host object (provided by the JS environment)</td><td align="left">Implementation-dependent</td></tr><tr><td align="left">Function object (implements [[Call]] in ECMA-262 terms)</td><td align="left">“function”</td></tr><tr><td align="left">Any other object</td><td align="left">“object”</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefinded</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">11</span> <span class="comment">// number</span></span><br><span class="line"><span class="comment">// also</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="number">11</span>) <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>) <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;11&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> (<span class="function">() =&gt;</span> &#123;&#125;) <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span> <span class="comment">// bigint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="number">2</span>) <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">2</span>) <span class="comment">// object</span></span><br></pre></td></tr></table></figure><blockquote><p>除了<code>null</code>与<code>function</code>外，其他都跟其类型相同</p></blockquote><p>如果想要获得一个正确的类型，还可以使用<code>Object.prototype.toString.call()</code>来判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">false</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">// &quot;[object Symbol]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">NaN</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="comment">// 另外</span></span><br><span class="line">[].toString() <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>].toString() <span class="comment">// &#x27;2,3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function">() =&gt;</span> &#123;&#125;) <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure><p>另外，在let、const以及class作用域中，如果在声明之前使用该变量，则会因为<code>temporal dead zone</code>而出现ReferenceError</p><p>对于没声明的变量则会返回<code>&#39;undefined&#39;</code></p><p><strong>13.2.1</strong> has an (informal?) note:<a target="_blank" rel="noopener" href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15">Ref: Why <code>typeof</code> is no longer “safe”</a></p><blockquote><p>let and const declarations define variables that are scoped to the running execution context’s LexicalEnvironment. The variables are created when their containing Lexical Environment is instantiated but <strong>may not be accessed</strong> in any way until the variable’s LexicalBinding is evaluated. A variable defined by a LexicalBinding with an Initializer <strong>is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created</strong>. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated.</p></blockquote><h2 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof">MDN</a></p><blockquote><p>instanceof 操作符 检测一个构造器的<code>prototype</code>是否存在于一个object的<code>原型链</code>中，即 instanceof 操作符左边是一个普通对象，右边是一个构造器（must be callable，or will get a TypeError）</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simpleString = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">let</span> stringObj = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;string object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">simpleString <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line">stringObj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nonObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">nonObj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>instanceof 操作符可以通过 <code>Symbol.hasInstance</code> 来改变行为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](instance) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(instance)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换一般有以下方法：</p><ul><li>通过<code>Boolean()</code>、<code>Number()</code>、<code>String()</code>、<code>parseInt()</code>、<code>parseFloat()</code>等转型函数来进行转换</li><li>通过<code>四则运算符操作符</code>和<code>==操作符</code>来进行转换</li></ul><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><table><thead><tr><th align="left">类型</th><th align="left">转化成false的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">false</td></tr><tr><td align="left">String</td><td align="left">‘’</td></tr><tr><td align="left">Number</td><td align="left">NaN 、 0</td></tr><tr><td align="left">Object</td><td align="left">null</td></tr><tr><td align="left">Undefined</td><td align="left">undefined</td></tr><tr><td align="left">Symbol</td><td align="left">-（全部转化为true）</td></tr></tbody></table><blockquote><p>其他都转换成true<br>在if语句中会自动执行Boolean进行类型转换</p></blockquote><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><table><thead><tr><th align="left">输入</th><th align="left">输出</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="left">true =&gt; 1, false =&gt; 0</td></tr><tr><td align="left">Number</td><td align="left">number =&gt; number</td></tr><tr><td align="left">Null</td><td align="left">null =&gt; 0</td></tr><tr><td align="left">Undefined</td><td align="left">undefined =&gt; NaN</td></tr><tr><td align="left">String</td><td align="left">`${number}` =&gt; number(包含浮点，其中十六进制转化为等值的十进制，忽略八进制等前导零), ‘’ =&gt; 0, other =&gt; NaN</td></tr><tr><td align="left">Object</td><td align="left">先调用valueOf()，按照前面规则，若得到NaN，再调用toString()，按照上述规则</td></tr></tbody></table><blockquote><p>一元操作符 <code>+</code>与<code>Number()</code>作用相同<br>在对象转基本类型的时候，可以使用<code>Symbol.toPrimitive</code>来控制其行为<br>Symbol不能转换为数字类型，否则会报错</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">obj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">233</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj + <span class="number">1</span>  <span class="comment">// 234</span></span><br></pre></td></tr></table></figure><h3 id="parseInt-、parseFloat"><a href="#parseInt-、parseFloat" class="headerlink" title="parseInt()、parseFloat()"></a>parseInt()、parseFloat()</h3><p>与Number不同：</p><ol><li>忽略字符串前面空格，如果第一个非空格字符不是数字或负号，则返回<code>NaN</code></li><li>如果第一个非空格字符是数字，则解析至最后或者遇到非数字字符</li><li>parseInt能够很好识别十进制、十六进制（ES5不具有解析八进制能力），但是parseFloat只能解析十进制，遇到十六进制会返回0</li><li>parseInt可以提供第二参数来指定基数</li><li>如果输入是<code>null</code>时，返回<code>NaN</code>，而<code>Number</code>返回<code>0</code></li><li>如果输入是<code>&#39;&#39;</code>时，返回<code>NaN</code>，而<code>Number</code>返回<code>0</code></li></ol><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><ol><li>如果有<code>toString()</code>方法，则调用toString方法（没有参数）</li><li>如果值是<code>null</code>或者<code>undefined</code>，则返回<code>&#39;null&#39;</code>或<code>&#39;undefined&#39;</code></li></ol><blockquote><p>一般<code>null</code>和<code>undefined</code>没有<code>toString()</code>方法</p></blockquote><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul><li>对于加法操作符<code>+</code>，如果有一个操作数为字符串，则将另一个转换为字符串，然后拼接字符串</li><li>其他运算如果有一个操作数是字符串、布尔值，先使用Number()转化为数值</li><li>对于<code>=</code>相等操作符与<code>!=</code>不相等操作符有<ol><li>如果有一个操作符是布尔值，则比较前转化为数值</li><li>如果一个为字符串一个为数值，则先转化为数值</li><li>如果一个是对象一个不是，则先调用valueOf</li><li>如果两个都是对象，则比较他们是不是同一对象</li><li>null == undefined</li><li>比较相等性之前，<strong>不能将<code>null</code>和<code>undefined</code>转化为其他值</strong></li></ol></li></ul><h1 id="块状作用域"><a href="#块状作用域" class="headerlink" title="块状作用域"></a>块状作用域</h1><ol><li>变量提升机制，一般函数优先度 &gt; 变量。<code>let</code>与<code>const</code>变量不提升</li><li>使用块状作用域中的变量所在的代码块中（即块状作用域），在声明前变量语句执行之前，变量会处于临时死区。</li><li>禁止重声明</li><li>在临时死区中，即使是<code>typeof</code>操作符也会触发引用错误（ReferenceError）</li><li>在<code>for-in</code>循环中，使用<code>const</code>声明变量不会报错，每次循环创建一个新的绑定</li><li><code>let</code>与<code>const</code>定义的变量作用域全局作用域上的时候，会遮蔽全局变量而不会覆盖</li></ol><h1 id="字符集扩展"><a href="#字符集扩展" class="headerlink" title="字符集扩展"></a>字符集扩展</h1><ol><li>code point</li><li>对于32bit的字符，<code>length</code> <code>charCodeAt</code> <code>/^.$/</code>出现错误</li><li><code>String.fromCodePoint()</code>,<code>.codePointAt</code>,<code>.normalize()</code></li><li>正则修饰符<code>u</code>，使用了两个编码单元处理的字符可以当成一个字符处理。单元操作模式 =&gt; 字符模式</li><li>可以使用正则来获得字符串的长度</li><li>增加以下方法：<ol><li>includes()</li><li>startsWith()</li><li>endsWith() 都可以通过设置偏移量</li><li>repeat()</li></ol></li></ol><h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><p>flag：</p><ul><li>g 全局模式</li><li>i 不分大小写</li><li>m 多行</li><li>u unicode支持</li><li>y sticky属性，表示是否可以设置index</li></ul><p>属性：</p><ul><li>flags</li><li>source</li><li>lastIndex</li></ul><p>方法：</p><ul><li>exec() 专门为捕获组设置的，接受一个参数，返回一个匹配项数组：第一个是整个模式匹配的字符串，其他是捕获组。同时还有index和input额外属性</li><li>test() 返回布尔值</li></ul><blockquote><p>对于exec来说，如果设置了g标志，每次也只会返回一个匹配项。</p></blockquote><h1 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h1><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = tag<span class="string">`Hello<span class="subst">$&#123;<span class="string">&#x27; &#x27;</span>&#125;</span>World`</span> <span class="comment">// tag 可以是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">literals, ...substitution</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// literals 为一个数组，它表示被$&#123;&#125;分隔的各个字符串</span></span><br><span class="line">  <span class="comment">// substitution是每一个$&#123;&#125;求值后的value</span></span><br><span class="line">  <span class="comment">// 可以使用literals.raw[i] 获取相应的原生值，同String.raw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的参数也位于临时死区，即前面一个参数默认值不能引用后面一个参数<br><strong>在setter中，不定参数只有一个</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">...value</span>) &#123; <span class="comment">// syntax error</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部有两个方法<code>[[Call]]</code>和<code>[[Construt]]</code><br>当使用<code>new</code>来调用的时候，使用<code>[[Construt]]</code>，否则通过<code>[[Call]]</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    <span class="comment">// 通过关键字 new 调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当时通过上述方法判断是否new调用会出现以下后果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">Person.call(person) </span><br></pre></td></tr></table></figure><p>所以采用<code>new.target</code>来判断是否new调用，如果是new调用，target内容为操作符的目标，即Person</p><p>块状作用域中声明函数，处于临时死区</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ul><li>没有this、super、argument和new.target的绑定</li><li>不能通过new调用</li><li>没有原型</li><li>不能改变this的指向</li><li>没有argument的绑定，始终访问外围函数的argument对象</li></ul><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发条件：</p><ol><li>尾调用不访问当前栈帧的变量</li><li>在函数内部，尾调用处于最后一条语句</li><li>尾调用的结果作为函数返回</li></ol><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>如果两个参数具有相同的类型且具有相同的值，则返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>mixin 混合</p><p>由于<code>Object.assign</code>使用了赋值操作，所以不能够将访问器属性复制到对象，最终会变成数据属性</p><p><code>const descriptor = Object.getOwnPropertyDescriptor(object, key)</code></p><h2 id="自由属性枚举顺序"><a href="#自由属性枚举顺序" class="headerlink" title="自由属性枚举顺序"></a>自由属性枚举顺序</h2><ol><li>数字键升序</li><li>字符串按照加入顺序</li><li>symbol按照加入顺序</li></ol><p><code>Object.getOwnPropertyNames(obj)</code></p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><code>Object.getPropertyOf(obj)</code> 和 <code>setPropertyOf(obj)</code></p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super相当于对象原型的指针<code>Object.getPropertyOf(this)</code><br><strong>如果在对象外的地方定义函数，使用super关键字会抛出 syntax error</strong><br>使用super的时候会调用函数的<code>[[HomeObject]]</code>属性获取原型，函数的<code>[[HomeObject]]</code>在定义的时候就确定了，所以就导致了下面的事情发生：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.say()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj1\&#x27;s prototype`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj2, &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj2\&#x27; prototype`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj2.say = obj1.say</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> say = obj1.say</span><br><span class="line"></span><br><span class="line">obj2.say() <span class="comment">// obj1&#x27;s prototype</span></span><br><span class="line"></span><br><span class="line">say() <span class="comment">// obj1&#x27;s prototype</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><p>非同名局部变量赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>:localName, <span class="attr">age</span>:localAge &#125; = node</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(localName, localAge) <span class="comment">// foo 2</span></span><br></pre></td></tr></table></figure><p>嵌套对象解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">loc</span>: &#123;start&#125;&#125; = node</span><br></pre></td></tr></table></figure><p>数组结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , thirdColor] = colors</span><br></pre></td></tr></table></figure><p>交换变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure><p>函数参数解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">name ,value, &#123; secure, path &#125;</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p>Symbol是一个原始值，所以不能使用new语法<code>new Symbol</code>(Type Error)，需要直接调用<code>const firstName = Symbol()</code></p><p>创建Symbol的时候可以可选添加一段文本描述，这个文本描述存储在内部的<code>[[Description]]</code>中，只有使用<code>toString()</code>才能访问到</p><p>Symbol可以使用在：</p><ol><li>对象字面量属性名</li><li><code>Object.defineProperty()</code></li><li><code>Object.defineProperties()</code></li></ol><p><strong>使用<code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>创建新的属性时候，默认为false</strong></p><h2 id="Symbol-共享体系"><a href="#Symbol-共享体系" class="headerlink" title="Symbol 共享体系"></a>Symbol 共享体系</h2><p><code>Symbol.for()</code>接受一个字符串参数，这个方法首先会在全局Symbol注册表中搜索键为参数的Symbol，如果存在，则返回已有Symbol，如果不存在，则创建一个新的Symbol</p><blockquote><p>symbol 不能转化为数字和字符串，所以在数字操作符中会报错，但是可以用在逻辑操作符中，其布尔等价值为true， 在 &lt;/&gt;比较中，会将symbol转化为number，所以也不能使用</p></blockquote><h2 id="属性检索"><a href="#属性检索" class="headerlink" title="属性检索"></a>属性检索</h2><p>一般可以通过下面的方法检索属性值</p><ul><li>Object.keys() 返回可枚举型，只枚举自身（for-in循环还枚举原型上的）</li><li>Object.getOwnPropertyNames() 不考虑枚举一律返回</li><li>Object.getOwnPropertySymbols() 检索对象中的symbol属性</li></ul><h2 id="Well-konwn-Symbol"><a href="#Well-konwn-Symbol" class="headerlink" title="Well-konwn Symbol"></a>Well-konwn Symbol</h2><ul><li>Symbol.hasInstance 执行instanceof时调用的内部方法，其为不可写不可配置不可枚举，需要用<code>Object.defineProperty</code></li><li>Symbol.isConcatSpreadable 一个布尔值，表示使用<code>concat</code>是否将集合规整到同一层级</li><li>Symbol.iterator 返回迭代器</li><li>Symbol.match 调用<code>String.prototype.match</code>时候调用方法，用于比较字符串</li><li>Symbol.replace</li><li>Symbol.search</li><li>Symbol.species 创建派生类的构造函数</li><li>Symbol.split 用于分割字符串</li><li>Symbol.toPrimitive 返回对象原始值，传入一个hint</li><li>Symbol.toStringTag 调用<code>toString</code>时候的方法</li><li>Symbol.unscopables 定义一些不可被with语句引用的对象属性名称集合</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hasLengthOf10 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.search]: <span class="function"><span class="keyword">function</span>(<span class="params">vaue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.legnth === <span class="number">10</span> ? <span class="number">0</span> : -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message1 = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">message1.search(hasLengthOf10)</span><br></pre></td></tr></table></figure><h1 id="Set-与-Map"><a href="#Set-与-Map" class="headerlink" title="Set 与 Map"></a>Set 与 Map</h1><p><code>in</code>操作符除了会检索对象中的属性，还会检索原型。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure><p>在set中，不存在类型转换，（引擎内部采用Object.is来检测两个值是否一致）<br><strong>Set 可以接受所有可迭代对象作为参数，数组、Set集合、Map集合等都是可迭代的</strong></p><p>方法：</p><ul><li>add()</li><li>has()</li><li>delete()</li><li>clear()</li><li>forEach() 同数组方法，回调函数前两个参数相同，接受第二个参数（this的值）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataSet.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="built_in">this</span>)</span><br></pre></td></tr></table></figure><ul><li>size</li></ul><blockquote><p>展开运算符可以将想Set集合的可迭代对象转换为数组</p></blockquote><p>创建无重复元素新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 只存储对象的弱引用，并且不可以存储原始值。集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</p><blockquote><p>如果 Weak Set 中包含任何原始值，就会抛出错误Type Error</p></blockquote><ul><li>WeakSet 不可迭代，所以没有for-of循环，forEach方法，keys和values方法，也没有clear方法</li><li>不支持size属性</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map的键名和对应的值支持所有的数据类型，键名的等价性是通过<code>Object.is()</code>方法进行判断的。</p><p>方法：</p><ul><li>set()</li><li>get() 如果不存在则返回 undefined</li><li>has(key)</li><li>delete(key)</li><li>clear()</li><li>forEach() 同数组方法</li><li>size</li></ul><p>Map同Set，可以<strong>通过传数组来初始化</strong>，其中每一个键值对都是一个数组</p><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap是弱引用的Map集合，在WeakMap的键名必须是一个对象，如果使用非对象也会报错。如果在弱引用之外不存在其他强引用，GC会回收这个对象，同时会移除WeakMap中的键值对。</p><p>WeakMap键名对应的value是强引用，value可以是任何类型</p><ul><li>WeakMap也不支迭代，所以不支持 clear、forEach</li><li>WeakMap可以用来创建私有数据</li></ul><h1 id="迭代器iterator和生成器generator"><a href="#迭代器iterator和生成器generator" class="headerlink" title="迭代器iterator和生成器generator"></a>迭代器iterator和生成器generator</h1><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><p>生成器是一种返回迭代器的函数，通过 function 关键字后的星号*来表示，函数还会用到新的关键字 yield</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a:&#x27;</span>,a) <span class="comment">// 如果在外部不显式向 next 函数传入参数，则 yield 返回值永远为 undefined</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b:&#x27;</span>, b)</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;c:&#x27;</span>,c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每遇到一个<code>yield</code>语句都会停止，调用next方法的时候才会继续运行</p><p><code>yield</code>关键字<strong>只能在<code>generator</code>内部运行</strong>，与return关键字一样，<strong>不能穿透函数边界</strong>，所以即使写在函数内部定义的函数里面也会报错<code>sytax error</code></p><blockquote><p>不能使用箭头函数创建 生成器</p></blockquote><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>可迭代对象具有 <code>Symbol.iterator</code>属性，其可以通过指定函数返回一个作用于附属对象的迭代器。其可以影响<code>for-of</code>循环</p><blockquote><p>如果将<code>for-of</code>循环用于不可迭代对象，null或undefined，会抛出错误 TypeError,而<code>for-in</code>就不会</p></blockquote><p>一般自己创建的对象都是不可迭代的，需要添加<code>Symbol.iterator</code>来使其变成可迭代对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collections = &#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h3><p>对于三种可迭代对象：数组、Set集合、Map集合，有：</p><ul><li>entries() 返回一个迭代器，其值为多个键值对，Map的默认迭代器</li><li>values() 返回一个迭代器，其值为集合的值，数组和Set的默认迭代器</li><li>keys() 返回要给迭代器，其值为所有键名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors  = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> color <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于数组，<code>for-of</code>循环返回的是其数字类型的索引，<code>for-in</code>循环返回的是数组属性的索引（即如果给数组添加属性a，也会在for-in循环中遍历）</p></blockquote><p>可以用解构语法在<code>for-of</code>循环中。</p><blockquote><p>字符串也有迭代器，通过使用<code>for-of</code>循环可以输出支持unicode的字符</p></blockquote><h3 id="Nodelist-迭代器"><a href="#Nodelist-迭代器" class="headerlink" title="Nodelist 迭代器"></a>Nodelist 迭代器</h3><p>Nodelist也内置了迭代器，其行为与数组一致</p><h3 id="高级迭代器功能"><a href="#高级迭代器功能" class="headerlink" title="高级迭代器功能"></a>高级迭代器功能</h3><p>第一次调用<code>next()</code>方法的时候无论传进什么参数都会被丢弃。由于传给<code>next()</code>方法的参数会代替上一个yield的返回值，而第一次调用next的时候前不会执行任何的yield语句，所以第一次调用next方法的时候传递参数是毫无意义的</p><h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><p><code>iterator.throw(new Error())</code>，这个函数可以返回类似next返回的值（但是如果内部error没有处理，就会导致代码停止执行）</p><h4 id="返回语句"><a href="#返回语句" class="headerlink" title="返回语句"></a>返回语句</h4><p>在生成器中定义函数的返回语句，会使迭代器提早进入done状态，并且当状态为done的时候，value为return的返回值（只会出现一次，之后会重置为undefined）</p><blockquote><p>展开运算符和<code>for-of</code>循环会直接忽略return语句的返回值，只要done状态变成true就会退出循环</p></blockquote><h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><p>将两个迭代器合二为一</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">colorGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;blue&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 这个值不会输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">numGenerator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) <span class="keyword">yield</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="keyword">yield</span> *colorGenerator() <span class="comment">// 其中 count 的值为 colorGenerator中的return值</span></span><br><span class="line">  <span class="keyword">yield</span> *numGenerator(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = generator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;red&quot;, done: false&#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123;value: &quot;blue&quot;, done: false&#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123;value: 0, done: false&#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以直接用于字符串，使用其默认迭代器 <code>yield *&#39;Hello World&#39;</code></p></blockquote><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>属性只能在constructor上构建（React可以直接在class块内）</p><p><code>typeof</code>返回<code>function</code></p><ol><li>函数声明会提升，但是类声明和let、const一样不能被提升</li><li>在类中，所有方法都是不可枚举的</li><li>每一类都有一个名为<code>[[Construct]]</code>内部方法，而方法中不含有<code>[[Construct]]</code>，用new调用这些方法会导致报错（在对象中也是一样）</li><li>使用除关键字<code>new</code>以外的语法会抛出错误TypeError</li><li>在类中修改类名会导致报错，在一般函数上则不会报错。类名在类中为常量（类似与const声明）。</li><li>类中可以使用<code>extends</code>语法</li><li>在类中，<code>new.target</code>永远不为undefined，指向构造函数（extends中，在基类的构造函数和派生构造函数是一样的）</li></ol><p>表达式声明与声明式声明区别：函数的name不同</p><p>命名类表达式（跟function 一样）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personClass = <span class="class"><span class="keyword">class</span> <span class="title">personClass2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> personClass <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> personClass2 <span class="comment">// undefined，只能在class内部使用</span></span><br></pre></td></tr></table></figure><p>另一种声明方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hi &#x27;</span>, <span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">age</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  *<span class="function"><span class="title">generator</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super-1"><a href="#super-1" class="headerlink" title="super"></a>super</h2><ol><li>只能在派生的构造函数中使用super()，即使用的<code>extends</code>语法创建的类，否则会报错</li><li>构造函数在访问this之前一定要使用super，它负责初始化this，否则会报错</li><li>如果不想使用this只能让constructor返回一个对象，但是此时该对象不会继承prototype</li></ol><p>如果基类有静态成员，那么这个<strong>静态成员在派生类中也可使用</strong></p><p>ES5中传统继承内建对象：先由派生类型创建this，然后调用基类型的构造函数（Array.apply(this)）。这意味着this的值开始是指向派生类型的，但随后会被来自（Array）的其他属性修饰</p><p>ES6中的继承：先由基类创建this值，访问基类所有内建功能，然后再正确地接收所有与之相关的功能。</p><p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h2><p>用于定义返回函数的静态访问器属性，允许子类覆盖构造函数。</p><p>以下内建类型均已定义：</p><ul><li>Array</li><li>ArrayBuffer</li><li>Map</li><li>Set</li><li>Promise</li><li>RegExp</li><li>Typed arrays</li></ul><p>类似这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般来说，只想要在类中调用<code>this.constrctor</code>，就应该会使用<code>Symbol.species</code>属性</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>Array.of</li><li>Array.from</li><li>Array.prototype.find()</li><li>Array.prototype.findIndex()</li></ul><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h2><p>这个函数是为了解决ES5中 <code>new Array()</code>中的参数问题：如果输入的是一个数字，则变成数组的length，否则变成数组的元素<br>在<code>Array.of()</code>中，无论输入什么都会变成数组的元素</p><blockquote><p>Array.of 不通过 Symbol.species的值确定返回值类型，它使用当前构造函数的this值来确定正确的返回数据类型</p></blockquote><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>类数组 =&gt; 数组<br>接收一个<strong>可迭代</strong>对象或类数组对象作为第一个参数，最终返回一个数组，可用展开符来代替<br>接收第二个参数表示映射，即类似 value =&gt; value + 1<br>接收第三个参数表示映射函数的this值</p><h2 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h2><p>===–&gt; 与 indexOf 和 lastIndexOf<br>二者都接收两个参数，一个为回调函数，另一个为回调函数的this值。回调函数的参数值与map一致<br>如果符合查找的值，返回true。find会返回查找到的值，findIndex会返回查找的Index</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>接收三个参数，填充的值，开始索引（包含），结束索引（不包含），如果为负数则加上数组长度</p><h2 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h2><p>接收三个参数，第一个是开始填充值的索引位置，第二个是开始复制值的索引位置，第三个为指定停止复制值的位置</p><blockquote><p>如果只指定两个，就会从复制值索引开始直到没有更多可复制的值为止。</p></blockquote><h2 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h2><ol><li><code>NaN</code>可以识别</li><li><code>-0</code> 与 <code>+0</code> 不可以识别，与<code>indexOf</code>一样</li></ol><blockquote><p>indexOf 使用全等操作符</p></blockquote><h2 id="定型数组-typed-array"><a href="#定型数组-typed-array" class="headerlink" title="定型数组 typed array"></a>定型数组 typed array</h2><p>这是一种用于处理数值类型数据的专用数组，将任何数字转换为一个包含数字比特的数组</p><p>定型数组支持存储和操作以下8中数据类型</p><ul><li>int8</li><li>uint8</li><li>int16</li><li>uint16</li><li>int32</li><li>uint32</li><li>bigInt64</li><li>bigUInt64</li><li>float32</li><li>float64</li></ul><h3 id="数组缓冲区-ArrayBuffer"><a href="#数组缓冲区-ArrayBuffer" class="headerlink" title="数组缓冲区 ArrayBuffer"></a>数组缓冲区 ArrayBuffer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>) <span class="comment">// 分配 10Byte</span></span><br><span class="line">buffer.byteLength <span class="comment">//10</span></span><br><span class="line"><span class="keyword">let</span> buffer2 = buffer.slice(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">buffer2.byteLength <span class="comment">// 1</span></span><br><span class="line">buffer.byteLength <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><blockquote><p>数组缓冲区包含的实际字节在创建时就已经确定，可以修改缓冲区数据，但是不能改变缓冲区的尺寸大小</p></blockquote><h3 id="视图-DataView"><a href="#视图-DataView" class="headerlink" title="视图 DataView"></a>视图 DataView</h3><p>视图是用来操作内存的接口，视图可以操作数组缓冲区或者缓冲区字节的子集，并按照其中一种数据类型来读取和写入数据。</p><p>支持上述8种数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">0</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>DataView接收三个参数：buffer，开始索引，数量</p><p>view属性</p><ul><li>buffer</li><li>bufferOffset</li><li>byteLength</li></ul><h4 id="读取和写入数据"><a href="#读取和写入数据" class="headerlink" title="读取和写入数据"></a>读取和写入数据</h4><p>get 方法接收两个参数：读取数据时的偏移量，可选布尔值，表示是否按照小序端进行读取。<br>set 方法接收三个参数：写入数据偏移量，写入的值，可选布尔值</p><ul><li>getInt8()</li><li>setInt8()</li><li>getUint8()</li><li>setUint8()</li><li>…</li><li>getFloat32()</li><li>getFloat64()</li></ul><h4 id="定型数组即视图"><a href="#定型数组即视图" class="headerlink" title="定型数组即视图"></a>定型数组即视图</h4><p>构造器</p><ul><li>Int8Array</li><li>Uint8Array</li><li>…</li></ul><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>事件模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>回调模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nodejs</span></span><br><span class="line">readFile(<span class="string">&#x27;file.txt&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>问题：回调地狱、实现并行执行两个操作，同时完成的时候通知或者优先完成的通知</p><h2 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h2><ol><li>pending</li><li>Fulfilled / Rejected</li></ol><p>内部属性<code>[[PromiseStatus]]</code>被用来表示Promise的三种状态<code>pending, fulfilled, rejected</code></p><p>方法：</p><ul><li>then() 第一个为处理fulfilled状态的，第二个为处理rejected状态的</li><li>catch() 发生错误使触发状态的</li><li>finally() 无论是fulfilled还是rejected都会触发</li></ul><blockquote><p>如果一个Promise处于已处理状态，在这之后添加到任务队列中的处理程序仍将执行，会将其添加到任务队列中。</p></blockquote><ul><li>Promise.resolve()</li><li>Promise.reject()</li></ul><blockquote><p>如果向上面两个函数传进去一个Promise，则会把这个promise直接返回<br>如果是非Promise的thenable对象（拥有then方法并且接收resolve和reject这两个参数的普通对象），<br>那么这些方法会创建一个新的Promise，并在then函数中被调用</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    reject(<span class="number">23</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let p0 = Promise.resolve(2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line"><span class="comment">// p status:rejected value:23</span></span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>对于一些没有拒绝处理程序的Promise，JavaScript没有强制报错(浏览器在最新版本报错)<br>在nodejs中，处理Promise拒绝时会触发process对象上两个事件</p><ul><li>unhandledRejection 在一个事件循环中</li><li>rejectionHandled 在一个事件循环后<br>function(reason, promise){}</li></ul><p>在浏览器中，触发window上的两个事件：</p><ul><li>unhandledrejection</li><li>rejectionhandled<br>function(type, promise, reason)</li></ul><h2 id="多个Promise"><a href="#多个Promise" class="headerlink" title="多个Promise"></a>多个Promise</h2><ul><li>Promise.all()，接收一个可迭代对象，如数组，then返回的value是一个数组，如果一个被拒绝，那么整个promise就会立即进入拒绝状态</li><li>Promise.race()，参数同上，如果有一个位于完成状态就会触发fulfilled或者rejected状态</li></ul><h1 id="Proxy-and-Reflection"><a href="#Proxy-and-Reflection" class="headerlink" title="Proxy and Reflection"></a>Proxy and Reflection</h1><p>调用<code>new Proxy()</code>可创建代替其他目标（target）对象的代理，它虚拟化了目标，所以二者看起来功能一致。<br>代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发相应特定操作的陷阱函数。<br>每一个代理陷阱对应着一个命名和参数都相同的Reflect方法。</p><p>代理陷阱（traps）</p><ol><li>get read</li><li>set write</li><li>has in operator</li><li>deleteProperty delete operator</li><li>getPrototypeOf Object.getPrototypeOf</li><li>setPrototypeOf Object.setPrototypeOf</li><li>isExtensible Object.isExtensible</li><li>preventExtensions Object.preventExtensions</li><li>getOwnPropertyDescriptor Object.getOwnPropertyDescriptor</li><li>defineProperty Object.defineProperty</li><li>ownKeys Object.keys()/Object.getOwnPropertyNames()/Object.getOwnPropertySymbols()</li><li>apply 调用一个函数</li><li>construct 用new调用一个函数</li></ol><blockquote><p>不适用陷阱的处理程序等价于简单的转发处理</p></blockquote><h2 id="set-trap"><a href="#set-trap" class="headerlink" title="set trap"></a>set trap</h2><p>接收4个参数</p><ul><li>trapTarget 代理的目标对象</li><li>key</li><li>value</li><li>receiver 操作发生的对象（通常是代理）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">trapTarget, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// only change to own property</span></span><br><span class="line">    <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;number&#x27;</span> || <span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;must be number&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// you can change the property exited in target wharever you want</span></span><br><span class="line">proxy.name = <span class="string">&#x27;mike&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when you assign a string to a property that do not exited in target</span></span><br><span class="line"><span class="comment">// you will get a TypeError</span></span><br><span class="line">proxy.count = <span class="string">&#x27;foo&#x27;</span> <span class="comment">// error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Reflect是set陷阱对应的反射方法和默认特性，它和set代理陷阱一样接受相同的4个参数。</p><p>如果属性已设置陷阱应该返回true，如果未设置返回false</p><h2 id="get-trap"><a href="#get-trap" class="headerlink" title="get trap"></a>get trap</h2><ul><li>trapTarget</li><li>key</li><li>receiver</li></ul><h2 id="has-trap"><a href="#has-trap" class="headerlink" title="has trap"></a>has trap</h2><ul><li>trapTarget</li><li>key</li></ul><h2 id="deleteProperty-trap"><a href="#deleteProperty-trap" class="headerlink" title="deleteProperty trap"></a>deleteProperty trap</h2><p>如果成功返回true，如果失败返回false</p><ul><li>trapTarget</li><li>key</li></ul><h2 id="原型代理"><a href="#原型代理" class="headerlink" title="原型代理"></a>原型代理</h2><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><ul><li>trapTarget</li><li>proto</li></ul><blockquote><p>如果操作失败返回一定是false，此时Object.setPrototypeOf()会报错</p></blockquote><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><ul><li>trapTarget</li></ul><blockquote><p>getPrototypeOf必须返回对象或者null<br>返回值检查可以确保Object.getPrototypeOf()返回的总是预期的值<br>Object.getPrototypeOf如果传进一个非对象值，会强制转化成对象<br>但是Reflect.getPrototypeOf传进一个非对象值，会报错</p></blockquote><h2 id="对象可扩展性陷阱"><a href="#对象可扩展性陷阱" class="headerlink" title="对象可扩展性陷阱"></a>对象可扩展性陷阱</h2><h3 id="preventExtensions-amp-isExtensiable"><a href="#preventExtensions-amp-isExtensiable" class="headerlink" title="preventExtensions &amp; isExtensiable"></a>preventExtensions &amp; isExtensiable</h3><p>二者都接收一个参数，如果成功返回true，如果失败返回false</p><ul><li>trapTarget</li></ul><h2 id="属性描述符陷阱"><a href="#属性描述符陷阱" class="headerlink" title="属性描述符陷阱"></a>属性描述符陷阱</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><ul><li>target</li><li>key</li><li>descriptor</li></ul><blockquote><p>无论什么对象传进去defineProperty，都只有属性：configurable,enumerable,value,writable,set,get,多余的将会设置为undefined<br><strong>返回值为false或者true</strong>，其中false时候会抛出错误<br>Object.defineProperty 返回第一个参数，即target</p></blockquote><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><ul><li>trapTarget</li><li>key</li></ul><blockquote><p>返回一个对象，null或者undefined，对象中（descriptor）不允许出现除了上述属性外的属性，否则报错<br>若调用 <code>Reflect.getOwnPropertyDescriptor</code>传入原始值，会抛出抛出一个错误<br>但是调用<code>Object.getOwnPropertyDescriptor</code>传入原始值，会强制转化成对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Reflect</span>.getOwnPropertyDescriptor(<span class="number">2</span>, <span class="string">&#x27;name&#x27;</span>) <span class="comment">// throw Error</span></span><br></pre></td></tr></table></figure><h2 id="ownKeys-trap"><a href="#ownKeys-trap" class="headerlink" title="ownKeys trap"></a>ownKeys trap</h2><p>ownKeys可以拦截内部方法<code>[[OwnPropertyKeys]]</code>，可以通过一个数组的值覆写其行为</p><p>该数组被用于：</p><ul><li>getOwnPropertyNames()</li><li>getOwnPropertySymbols()</li><li>Object.keys()</li><li>Object.assign()</li></ul><p>参数：</p><ul><li>trapTarget</li></ul><h2 id="apply-amp-construct"><a href="#apply-amp-construct" class="headerlink" title="apply &amp; construct"></a>apply &amp; construct</h2><p>改变函数内部<code>[[Call]]</code>以及<code>[[Contruct]]</code>属性</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul><li>trapTarget</li><li>thisArg this的值</li><li>argumentsList</li></ul><h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><ul><li>trapTarget</li><li>argumentsList</li></ul><blockquote><p>Reflect.construct()方法除了接受上面两个参数之外，还接受第三个参数：newTarget<br>原型链的查找不受代理的影响</p></blockquote><p>应用：验证函数参数，拦截<code>new</code>调用，覆写抽象基类构造函数，可调用类构造函数。。。（在自己无法控制代码的时候使用代理，如Number()）</p><h2 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h2><p>通常，在创建代理之后，代理不能脱离其目标。<br>可以使用<code>Proxy.revocale()</code>方法创建可撤销的代理。返回一个对象：1. proxy 2. revoke （撤销代理用的函数）<br>执行<code>revoke()</code>之后，任何与代理对象交互的尝试都会出发代理陷阱抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="number">12</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br><span class="line"></span><br><span class="line">revoke()</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="number">233</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><h2 id="从构造函数返回一个代理"><a href="#从构造函数返回一个代理" class="headerlink" title="从构造函数返回一个代理"></a>从构造函数返回一个代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="built_in">this</span>, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"></span><br><span class="line">person <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h1><ol><li>模块的顶部，this的值为undefined</li><li>模块不支持HTML风格的注释</li></ol><p>导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a</span><br><span class="line"><span class="keyword">export</span> &#123;a <span class="keyword">as</span> sum, b, Person&#125; <span class="comment">// 导出的是sum</span></span><br></pre></td></tr></table></figure><p>导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1 &#125; <span class="keyword">from</span> <span class="string">&#x27;./main.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> sample <span class="keyword">from</span> <span class="string">&#x27;./main.js&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>这个语法不是解构</p></blockquote><p>重新导出一个绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./main.js&#x27;</span></span><br></pre></td></tr></table></figure><p>在浏览器中使用模块：</p><ol><li>script 标签 type 设置为 “module”，不需要添加defer参数，因为默认存在</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./example.js&quot;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行顺序：（显示引入scirpt和隐式引入的所有模块都是按需加载并执行）</p><ol><li>下载module.js</li><li>递归下载并解析module.js中导入的资源</li><li>解析内联模块</li><li>递归解析内联模块中导入的资源</li></ol><p>加载完毕后：</p><ol><li><p>递归执行module.js中导入的资源</p></li><li><p>执行module.js</p></li><li><p>递归执行内联模块中导入的资源</p></li><li><p>执行内联模块.</p></li><li><p>文件当成woker执行</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&#x27;module.js&#x27;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><div class="post-button text-center"><a class="btn scaleup" href="/2019-02-05-javascirpt-fundamental/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/6/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><picture><source srcset="/images/card.webp" type="image/webp"><img loading="lazy" class="site-author-image" itemprop="image" src="/images/card.jpg" alt=""></picture><p class="site-author-name" itemprop="name">everbrez</p><p class="site-description motion-element" itemprop="description">你能抓到我么？</p></div><div class="links-of-author motion-element"><span class="links-of-author-item scaleup"><a href="https://github.com/everbrez" target="_blank" title="GitHub"><i class="fab fa-github" style="color:#191717"><span>everbrez</span></i></a></span></div><div class="des-of-author"><div class="des-of-author-nav"><div class="des-of-author-title active" data-index="1">最喜欢的作品</div><div class="des-of-author-title" data-index="2">最喜欢的女孩子</div><div class="des-of-author-title" data-index="3">最喜欢的游戏</div></div><div class="des-of-author-panel"><div class="des-of-author-des active" data-index="1">路人女主的养成方法、我的青春恋爱物语果然有问题</div><div class="des-of-author-des" data-index="2">加藤惠</div><div class="des-of-author-des" data-index="3">Minecraft</div></div></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-image"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/footer.png"></picture></div><div class="footer-inner"><p>博客已萌萌哒运行<span id="since"></span><span class="my-face">(●'◡'●)ﾉ♥</span></p><p>© <span itemprop="copyrightYear">2021</span> Hi, everbrez. 由 <a href="https://hexo.io/" target="_blank" class="external" rel="nofollow">Hexo</a> 强力驱动. Theme By <a href="https://github.com/DIYgod/hexo-theme-sagiri" target="_blank" class="external" rel="nofollow">Sagiri</a> v0.0.74. <a href="/sitemap.xml" target="_blank">站点地图</a>.</p><p>Made with <i class="fas fa-heart throb" style="color:#d43f57"></i> by <span class="author" itemprop="copyrightHolder">everbrez</span>.</p></div></footer><div class="back-to-top"><picture><source srcset="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.webp" type="image/webp"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/DIYgod/diygod.me@gh-pages/images/scroll.png"></picture></div><canvas id="evanyou"></canvas></div><script type="text/javascript" src="/js/sagiri.min.js?v=0.0.74"></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js")})</script></body></html>