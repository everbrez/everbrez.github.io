---
layout: post
title: react
date:   2019-02-17
categories: javascript
---

# MVC
[!](../assets/images/mvc.png)
model 用来封装与应用程序的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型。一旦模型的数据发生变化，模型将通知有关的视图。

view 视图，当模型发生变化的时候，视图相应得到刷新自己的机会

controller 定义用户界面对用户输入的相应方式，起到不同层面的组织作用，用于控制应用程序的流程，它处理用户行为和数据model的改变。

其中：view和model之间是观察者模式，view观察model，实现在model上注册，以便view可以了解在数据model上发生的改变
view和controller是策略模式，view可以使用controller的方法

# MVP
model view Presenter 为MVC的一种衍生模式

切入点：解决controller和view的捆绑关系，将其进行改造，使view不仅拥有UI组件的结构，还拥有处理用户事件的能力。此时view不能调用model的方法，所以只能让presenter取更新model，在通过观察者模式更新view。
相比与传统MVC，解耦了model和view，完全分离视图和模型，使职责划分更加清晰。可以将view抽象出来做成组件。

（controller可以在view中复用）
应用逻辑主要集中再presenter这一层中。缺点：手动更新

# MVVM
最重要的使数据绑定，data-binding。
view和model不知道彼此的存在，同MVP一样，将view和model清晰地分离开，如果viewmodel的属性值改变了，这些新值通过数据绑定自动传递给view，反过来，viewmodel会暴露model中数据和特定状态给view。

此时的model是单纯的数据，不包含对数据的操作

Vue双向数据绑定：通过Object.defineProperty来实现绑定
[vue](https://juejin.im/post/593021272f301e0058273468#heading-9)

# flux
Flux将一个应用分成四个组成部分：
- View：视图
- Action：一个对象，视图发出的信息，包含一个type以及数据
- Dispatcher：接收Actions，执行回调函数
- Store：数据层，用来存放应用状态，提醒Views更新页面

Predictable
特点：单项数据流动

## control view
用来保存状态，监听store的变化，然后数据转发给子组件。
子组件不包含所有的状态，为纯组件。

## dispatcher
将action派发到store，dispatcher只有一个，而且是全局的。

# Virtual DOM

# router control

# lifecycle

# communication

# HOC & mixins

# event

# React
## element & component
element是由component生成的，element是一个对象，component是一个构造函数。
element是immutable（不能改变）的，一旦创建了就不能更改element的children、attributes等属性。

## state & props
props只能读，不能更改。所有的React Component 必须像纯函数那样对待他们的props

`this.props` 与 `this.state` 可能被异步更新，所以不能依靠他们来计算下一个`state`，要使用回调函数：
```js
this.setState((state, props) => ({counter: state.counter + props.counter}))
```

## dataflow
top-down/ unidirectional 数据流
state只能被特定的组件所拥有，所有的state数据更新只能影响这个组件树下层的组件

## Event
React的event使用驼峰写法，而不是全部小写
将一个函数传给下一个组件的事件，而不是字符串
（不能return false来阻止默认行为，只能使用preventDefault来）
React的事件是一个合成事件。所以不需要担心浏览器兼容性

## key
[](http://taobaofed.org/blog/2016/08/25/react-key/)
注意key相同可能引发错误，使用index作为key也可能引发错误。
以下三个条件满足的情况下中可以使用index作为key：
- list中的数据不会改变（即不会重新计算）
- list不会过滤或者重新保存（如排序）
- list中item没有唯一的id

### diff算法
[](https://zhuanlan.zhihu.com/p/20346379)

### virtual-dom
尝试去最小化回流/重绘步骤，从而在大型且复杂的项目中得到更好的性能
virtual-dom ---> fiber

#### stack-reconciler

#### fiber
[](http://www.ayqy.net/blog/dive-into-react-fiber/)

#### Reconciliation

## Accessibility
[](https://a11yproject.com/checklist.html)

## Lazy & Suspense
lazy接收一个含有`import`语句的回调，这个回调返回一个promise，（promise中必须有一个包含组件default export）
```js
const Component = React.lazy(() => import('./component'))

function MyComponent() {
  return (
    <Suspense fallback={<div>loading</div>}>
      <Component />
    </Suspense>
  )
}
```

## ErrorBoundary
```jsx
class ErrorBoundary extends Component {
  constructor(props) {
    super(props)
    this.state = {
      error: false,
      msg: ''
    }
  }

  static getDerivedStateFromError(err) {
    return {
      error: true,
      msg: error.message
    }
  }

  componentDidCatch() {

  }

  render() {
    const { error, msg } = this.state
    return (
      <>
      {error ? <div>error: {msg}</div> : this.props.children}
      </>
    )
  }
}
```
Error boundaries 不捕获下面的错误
- event handle
- 异步代码
- 服务器端渲染
- Error boundaries 自己抛出的错误

只有class组件才有error boundaries，与catch工作原理类似
在React 16 之后， 如果errors没有被catch，那么会把整个react组件树卸载。

## Context
`const MyContext = React.createContext(defaultValue)`
`defaultValue`只有在一个组件上方没有任何的`provider`的时候使用。

### Context.Provider
```jsx
<Context.Provider value={/* some value */} />
```
其中上方的value一般不使用字面量对象，一般使用this.state。因为如果是使用字面量对象，每次rerender的时候就会重新创建一个对象

### Class.contextType

### Context.Consumer

### Ref
ref 不是props的属性，如果需要实现穿越组件传递ref，需要使用下面的api
```jsx
React.forwardRef(function(props, ref) {...})

function logProps(Component) {
  class logProps extends React.Component {
    render() {
      const {forwardedRef, ...rest} = this.props
      return <Component ref={forwardedRef} {...rest} />
    }
  }

  return React.forwardRef((props, ref) => {
    return <LogProps {...props} forwardedRef={ref} />
  })
}
```
`React.forwardRef`接收一个render函数，这个函数接收两个props、ref
