---
layout: post
title:  os
date:   2019-02-22
categories: NetWork 
---

os
<!--more-->

# 进程和线程

## 缓存一致型

内存 -> CPU高速缓存 -> 内存

如果有多个线程运行，在多核CPU中，这条线程可能运行在不同的CPU，因此每个线程运行都有自己的高速缓存
如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

解决：

1. 在总线上加LOCK#锁的方式
2. 通过缓存一致性协议

CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的画，也就是说阻塞了其他CPU对其他部件访（如内存），使得只有一个CPU能使用这个变量的内存 ===> 导致了效率低下的问题

缓存一致性协议：该协议保证了每个缓存中使用的共享变量的副本时一致的。
核心思想：当CPU向内存写入数据时，如果发现操作的变量时共享变量，即在其他CPU也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态。因此当其他CPU需要读取这个变量时，发现自己缓存中缓存的缓存行时无效的，那么它就会从内存重新读取。

## 进程

进程是具有独立功能的程序，它是**系统进行资源分配和调度**的一个独立单位，可就是说进程可以独立运行一段程序

## 线程

线程是**CPU调度和分派**的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本不拥有系统资源
（只有计数器，一组寄存器和栈）
一个进程的多个线程可以独立运行。

## 关系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（主线程）
2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源，一个线程崩溃整个进程崩溃
3. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。（一个线程使用资源时，其他线程必须等它结束）
4. 处理机分给线程，真正在处理机上运行的线程
5. 线程是指进程内一个执行单元，也是进程内的可调度实体

单个CPU只能运行与一个任务，而进程就是CPU能处理的单个任务。任一时刻CPU总是运行一个进程，其他进程处于非运行状态。

互斥锁：防止多个线程同时读取某一块内存区域。
信号量机制：（满多少个信号就互斥）

# 进程之间的通信方式（IPC）？进程调度方法？

1. 共享内存：这是最有用的进程间通信方式。使多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存数据的更新。（需要依靠互斥锁或者信号量来同步）
2. 信息队列：信息队列使在信息的传输过程中保存消息的容器。具有写权限的进程可以按照一定规则向信息队列中添加新信息，对信息队列有读取权限的进程可以从信息队列中读取信息。
3. 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
4. 信号量是一个计数器，可以用来控制多个而进程对共享资源的访问，它常作为一种锁机制。防止某进程正在访问共享资源时，其他进程也访问该资源。
5. 套接字(socket)：这个一种更为一般的进程间通信机制，它可以用于网络中不同机器之间的进程之间通信，应用十分广泛。

调度方法；

1. 先来先服务调度算法
2. 短作业优先调度算法
3. 优先权调度算法
4. 基于时间片的轮转调度算法（轮转法调度）

# 线程间的通信方式

锁机制：互斥锁，条件变量，读写锁

- 互斥锁提供了以排他方式防止数据结构被并发修改的方法
- 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
- 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。与互斥锁一起使用

信号量机制：无名线程信号量和命名线程信号量

信号机制：类似进程间的信号处理，线程中的信号主要用于线程同步，所以没有向进程中用于数据交换的通信机制

# 操作系统组成部分

1. 进程管理
2. 存储管理
3. 设备管理
4. 文件管理
5. 程序接口
6. 用户界面

# 换页算法

在地址映射中，若在页面中要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间
系统换页方法：
FIFO 先进先出
LRU 最近最少使用least recently used，替换上次使用距离当前最远的页
Clock 给每个页关联一个使用位，当该页第一次装入内存或者被重新访问时，将使用位=>1，每次需要替换时，查找使用位为0的第一个帧替换。如果所有都是1，则替换第一个帧。扫描后变为0。
OPT 最佳替换算法（替换下次访问距当前时间最长的页）需要直到操作系统将来的事件（作为其他算法的衡量）

# 死锁条件及解决方法

## 死锁的概念

在两个或者多个并发过程中，如果每个进程持有某种资源而又等待其他进程释放它或他们保持着资源，在未改变这种状态之前不能向前推进，称这一组进程产生了死锁。就是两个或者多个进程无限期的阻塞、互相等待的一种状态。

## 死锁产生的四个必要条件

1. 互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他进程申请使用该资源，那么申请进程必须等待该资源被释放为止；
2. 占用并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他继承所占用
3. 非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放
4. 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

## 死锁的处理和预防

基本思想：只要确保死锁发生的四个必要条件至少有一个不成立，就能预防死锁的发生

1. 打破互斥条件：允许进程同时访问某些资源
2. 打破占有并等待条件：实行资源预先分配策略，进程在运行前一次性向系统申请它所需要的全部资源。（减低资源利用率）
3. 打破非抢占条件：允许进程强行从占有者那里夺取资源
4. 打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按照资源序号递增提出，只有占用了小号资源才能申请大号资源

避免：
动态检测资源分配状态，确保循环等待条件不成立。

死锁解除：进程终止和资源抢占