<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hi, everbrez</title>
  
  
  <link href="https://everbrez.github.io/atom.xml" rel="self"/>
  
  <link href="https://everbrez.github.io/"/>
  <updated>2021-05-22T12:26:05.492Z</updated>
  <id>https://everbrez.github.io/</id>
  
  <author>
    <name>everbrez</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020年总结</title>
    <link href="https://everbrez.github.io/2021-04-18-2020%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://everbrez.github.io/2021-04-18-2020%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-18T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>coming soon…</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;coming soon…&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://everbrez.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://everbrez.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://everbrez.github.io/2019-12-14-mysql/"/>
    <id>https://everbrez.github.io/2019-12-14-mysql/</id>
    <published>2019-12-14T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>mysql</p><span id="more"></span><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><ul><li><p>SHOW DATABASES;</p></li><li><p>SHOW TABLES;</p></li><li><p>USE DATABASE</p></li><li><p>CREATE DATABASE db_name</p></li><li><p>DROP DATABASE db_name</p></li><li><p>DESC table</p></li><li><p>SHOW CREATE TABLE table</p></li><li><p>DROP TABLE table</p></li><li><p>ALTER TABLE table ADD COLUMN col VARCHAR(10) NOT NULL</p></li><li><p>CHANGE COLUMN</p></li><li><p>DROP COLUMN</p></li><li><p>SELECT *<br>FROM table<br>WHERE condition<br>ORDER BY name DESC<br>LIMIT num OFFSET skip_num</p></li><li><p>SELECT COUNT(*) num<br>FROM table<br>GROUP BY name;</p></li><li><p>AVG(column)</p></li><li><p>SUM()</p></li><li><p>MAX()</p></li><li><p>MIN()</p></li><li><p>SELECT *<br>FROM table1, table2</p></li><li><p>alias<br>SELECT<br>s.id sid<br>s.name<br>s.gender<br>c.id cid<br>c.name cname<br>FROM students s, classes c;</p></li><li><p>SELECT<br>s.id<br>s.class_id<br>c.name class_name<br>FROM students s<br>INNER JOIN classes c<br>ON s.class_id = c.id;</p></li><li><p>RIGHT OUTER JOIN 右表溢出</p></li><li><p>LEFT OUTER JOIN</p></li><li><p>FULL OUTER JOIN</p></li></ul><ul><li><p>INSERT<br>INSERT INTO table (col1, col2) VALUES (val1, val2), (val3, val4);</p></li><li><p>UPDATE<br>UPDATE table SET col1=val1, col2=val2 WHERE condition;</p></li><li><p>DELETE<br>DELETE FROM table WHERE condition</p></li><li><p>REPLACE INTO</p></li><li><p>INSERT IGNORE INTO</p></li><li><p>INSERT INTO …… ON DUPLIOCATE KEY UPDATE col1=val1, col2=val2;</p></li><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;mysql&lt;/p&gt;</summary>
    
    
    
    <category term="database" scheme="https://everbrez.github.io/categories/database/"/>
    
    
    <category term="database" scheme="https://everbrez.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="https://everbrez.github.io/2019-12-13-typescript/"/>
    <id>https://everbrez.github.io/2019-12-13-typescript/</id>
    <published>2019-12-13T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>typescript</p><span id="more"></span><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><ul><li>number</li><li>string</li><li>object</li><li>boolean</li><li>null</li><li>undefined</li><li>void</li><li>never</li><li>any</li><li>string[] or Array<string></li><li>[string, number]</li><li>enum</li></ul><p>断言：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(variable <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><h2 id="描述对象或函数"><a href="#描述对象或函数" class="headerlink" title="描述对象或函数"></a>描述对象或函数</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelValue &#123;</span><br><span class="line">  <span class="attr">label</span>: <span class="built_in">string</span>;</span><br><span class="line">  color?: <span class="built_in">number</span>; <span class="comment">// 可选属性，表示在某一些情况下存在，某一些情况下不存在</span></span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>; <span class="comment">// 只读属性，与const区别：变量用const，属性用readonly</span></span><br><span class="line">  arr: readonlyArray&lt;T&gt;; <span class="comment">// 只读数组（将所有可变方法去掉）</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">// 字符串索引签名，定义其他额外属性</span></span><br><span class="line">  reset(): <span class="built_in">void</span>; <span class="comment">// 函数成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SearchFun &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, <span class="attr">substring</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [otherProps: <span class="built_in">string</span>]: <span class="built_in">string</span>; <span class="comment">// 二者可以同时存在，但是数字索引的返回值必须是字符串索引返回值类型的子集（包括extends等）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类-类型"><a href="#类-类型" class="headerlink" title="类 类型"></a>类 类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="built_in">Date</span>; <span class="comment">// 接口描述类的公共部分，不会检查私有成员; 同时此处是实例的成员，不检查类的静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> state: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelecableControl <span class="keyword">extends</span> Control &#123; <span class="comment">// 接口可以继承类，包括其私有成员</span></span><br><span class="line">  select(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="共有、私有与受保护的修饰符"><a href="#共有、私有与受保护的修饰符" class="headerlink" title="共有、私有与受保护的修饰符"></a>共有、私有与受保护的修饰符</h2><ul><li>public</li><li>private // 它不能在它的类外部访问；另外只有两个类的private来自同一处声明，才认为是兼容的，即可以相互赋值</li><li>protected // 它在派生成员中还可以访问</li><li>readonly</li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>abstract 一般用来定义抽象类以及抽象类内部的抽象方法，其本身不允许调用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span></span><br><span class="line">  move(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;move&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当声明类的时候，实际上也声明了类的实例类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point: Point = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;<span class="keyword">return</span> x + y&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x + y&#125;</span><br></pre></td></tr></table></figure><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>可以为对象的函数成员的参数列表最前面提供一个this</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">  createCardPicker(<span class="built_in">this</span>: Deck): <span class="function">() =&gt;</span> Card</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 尖括号内容为显式告诉T为string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型约束</span></span><br><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  <span class="attr">Up</span>: <span class="number">1</span>,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串枚举：每一个成员都必须使用字符串字面量</span></span><br><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  <span class="attr">Up</span>: <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  <span class="attr">Down</span>: <span class="string">&#x27;down&#x27;</span>,</span><br><span class="line">  <span class="attr">Left</span>: <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">  <span class="attr">Right</span>: <span class="string">&#x27;right&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;typescript&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning</title>
    <link href="https://everbrez.github.io/2019-10-15-machine-learning/"/>
    <id>https://everbrez.github.io/2019-10-15-machine-learning/</id>
    <published>2019-10-15T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习</p><span id="more"></span><p>机器学习有多种定义。</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Arthur Samuel 的定义(old, informal)</p><blockquote><p>the field of study that gives computers the ability to learn without being explicitly programmed.</p></blockquote><p>Tom Mitchell 的定义</p><blockquote><p>A computer program is said to learn from experience E with repect to some class of tasks T and performance measure P, if it’s performance at tasks in T, as measured by P, improves with experience E.</p></blockquote><p>例如： 下棋<br>E: 与众多棋手下棋的经验<br>T: 下棋<br>P: 下一局赢的概率</p><p>通常，机器学习可以分成两大类：</p><ol><li>监督学习(supervised learning)</li><li>无监督学习(unsupervised learning)</li></ol><p>可以通俗地理解上面两个概念：<br>监督学习是在人或者其他的帮助下学习，无监督学习是让机器自己学习。</p><h1 id="两种主要的机器学习算法"><a href="#两种主要的机器学习算法" class="headerlink" title="两种主要的机器学习算法"></a>两种主要的机器学习算法</h1><h2 id="监督学习-supervised-learning"><a href="#监督学习-supervised-learning" class="headerlink" title="监督学习(supervised learning)"></a>监督学习(supervised learning)</h2><p>在监督学习中，我们已经有一份知道了“正确答案”的数据集，认为输入与输出存在一个关系。也就是说，在监督学习中，我们首先会告诉机器正确答案（定义中的E）</p><p>监督学习可以分成：回归问题和分类问题</p><p>例子：预测房价、标记垃圾邮件</p><h2 id="无监督学习-unsupervised-learning"><a href="#无监督学习-unsupervised-learning" class="headerlink" title="无监督学习(unsupervised learning)"></a>无监督学习(unsupervised learning)</h2><p>无监督学习让我们无需知道结果是什么样子，即使我们不知道变量具体的作用，我们可以通过无监督学习来获取数据不同结构（聚类算法）</p><p>例子：谷歌新闻分类、鸡尾酒宴会</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;机器学习&lt;/p&gt;</summary>
    
    
    
    <category term="AI" scheme="https://everbrez.github.io/categories/AI/"/>
    
    
    <category term="AI" scheme="https://everbrez.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>web components</title>
    <link href="https://everbrez.github.io/2019-06-06-web-components/"/>
    <id>https://everbrez.github.io/2019-06-06-web-components/</id>
    <published>2019-06-06T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>Web Component 包含了以下三个技术：</p><ol><li>Custom Element: 可以定义自定义的元素，如 <code>&lt;my-button&gt;&lt;/my-button&gt;</code>，特点是包含一个中划线<code>-</code></li><li>ShadowDOM: 封装html和css</li><li>HTML Templates: 使用<code>&lt;template&gt;</code>标签来定义一个html fragment，但是他们不立即渲染，只有用到他们的时候才会渲染。</li><li>（未实现）HTML Modules</li></ol><span id="more"></span><blockquote><p>需要注意的是，上面的技术都是独立的，就是可以单独使用其中一种技术，也可以结合起来使用，还可以结合现在类似React、Vue等库来使用。</p></blockquote><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://css-tricks.com/an-introduction-to-web-components/">an-introduction-to-web-components</a></li></ol><h1 id="Custom-Element"><a href="#Custom-Element" class="headerlink" title="Custom Element"></a>Custom Element</h1><p>我们可以通过浏览器提供的API来定义自定义的html标签，实现类似原生<code>&lt;section&gt;</code>、<code>&lt;video&gt;</code>等功能。<br>与原生html标签不同的是，自定义的标签具有中划线<code>-</code>，如：<code>&lt;my-slider&gt;</code>。（可以参考youtube的html源码，里面多处用到Custom Element）</p><p>Custom-Element可以定义他们自己的语义、标志、行为，并且可以跨浏览器和框架运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myButton</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">connectedCallback</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;button&gt;</span></span><br><span class="line"><span class="string">        custom-button:</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="built_in">this</span>.innerHTML&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">&#x27;my-button&#x27;</span>, myButton)</span><br></pre></td></tr></table></figure><h1 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h1><p>Shadow DOM 可以用来封装 DOM，可以让用户更好地与其他html分离html fragment（类似组件化）</p><p>一个Shadow DOM 可以包含html代码、css样式等。</p><p>对比与 Light DOM: </p><ol><li>Shadow DOM 不能使用<code>document.querySelector</code>或者<code>element.querySelector</code>来获取，需要使用<code>shadowRoot.querySelector</code>来获取里面的元素</li><li>shadowRoot 是一段html fragment</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> myButtonShadowRoot = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#my-button&#x27;</span>).attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">// mode: open means that you can refer shadowRoot with `element.shadowRoot` property</span></span><br><span class="line"><span class="comment">// if set mode to closed, then use `element.shadowRoot` will return null</span></span><br><span class="line"></span><br><span class="line">myButtonShadowRoot.innerHTML = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;style&gt;</span></span><br><span class="line"><span class="string">    button &#123;</span></span><br><span class="line"><span class="string">      border: none;</span></span><br><span class="line"><span class="string">      background: none;</span></span><br><span class="line"><span class="string">      background: tomato;</span></span><br><span class="line"><span class="string">      color: white;</span></span><br><span class="line"><span class="string">      border-radius: 5px;</span></span><br><span class="line"><span class="string">      padding: .5em 2em;</span></span><br><span class="line"><span class="string">      box-shadow: none;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;button&gt;</span></span><br><span class="line"><span class="string">    &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/button&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><h1 id="HTML-Template"><a href="#HTML-Template" class="headerlink" title="HTML Template"></a>HTML Template</h1><p>使用<code>&lt;template&gt;</code>可以定义 HTML Template，在<code>&lt;template&gt;</code>中的代码不会马上渲染，而是在后面使用，可以提高代码的复用性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;book-template&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;book-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = [&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;book1&#x27;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&#x27;link to book1&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;book2&#x27;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&#x27;link to book1&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;book3&#x27;</span>,</span><br><span class="line">    <span class="attr">link</span>: <span class="string">&#x27;link to book1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#book-template&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.book-container&#x27;</span>)</span><br><span class="line"></span><br><span class="line">books.forEach(<span class="function"><span class="params">book</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> instance = <span class="built_in">document</span>.importNode(fragment.content, <span class="literal">true</span>)</span><br><span class="line">  instance.querySelector(<span class="string">&#x27;.link&#x27;</span>).innerText = book.title</span><br><span class="line">  instance.querySelector(<span class="string">&#x27;.link&#x27;</span>).href = book.link</span><br><span class="line">  container.append(instance)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Web Component 包含了以下三个技术：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Custom Element: 可以定义自定义的元素，如 &lt;code&gt;&amp;lt;my-button&amp;gt;&amp;lt;/my-button&amp;gt;&lt;/code&gt;，特点是包含一个中划线&lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ShadowDOM: 封装html和css&lt;/li&gt;
&lt;li&gt;HTML Templates: 使用&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;标签来定义一个html fragment，但是他们不立即渲染，只有用到他们的时候才会渲染。&lt;/li&gt;
&lt;li&gt;（未实现）HTML Modules&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="frontend" scheme="https://everbrez.github.io/categories/frontend/"/>
    
    
    <category term="frontend" scheme="https://everbrez.github.io/tags/frontend/"/>
    
  </entry>
  
  <entry>
    <title>redis</title>
    <link href="https://everbrez.github.io/2019-06-01-redis/"/>
    <id>https://everbrez.github.io/2019-06-01-redis/</id>
    <published>2019-06-01T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个高性能的key-value数据库</p><span id="more"></span><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>支持数据持久化，可以将内存中的数据保存在硬盘中，重启中再次加载可用。</li><li>不仅仅提供key-value类型的数据，还支持list、set、zset、hash等数据结构的存储</li><li>支持数据备份，即master-slave模式的数据备份</li><li>性能极高</li><li>丰富的数据结构</li><li>原子操作</li><li>丰富的特性：key过期等等</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis支持五种数据类型，string、hash、list、set、zset（有序集合，sorted set）</p><h2 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h2><p>string值是redis中最基本的值，一个key对应一个value。<br>string类型是二进制安全的，这意味着可以包含任何数据，比如jpg图片或者序列化对象。<br>string类型最大能够存储512M的数据</p><h2 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash 哈希"></a>hash 哈希</h2><p>hash是一个键值对集合（key =&gt; value）集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HMSET myhash field1 value1 field2 value2</span><br><span class="line"></span><br><span class="line">HGET myhash field1</span><br><span class="line">// value1</span><br><span class="line"></span><br><span class="line">HGETALL myhash</span><br><span class="line">1) field1</span><br><span class="line">2) value1</span><br><span class="line">3) field2</span><br><span class="line">4) value2</span><br></pre></td></tr></table></figure><h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><p>Redis列表是简单的字符串列表，按照插入的顺序排序。可以添加一个元素到列表的头部和尾部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpush mylist value1</span><br><span class="line">lpush mylist value2</span><br><span class="line"></span><br><span class="line">lrange mylist 0 10</span><br><span class="line">//result:</span><br><span class="line">// 1) <span class="string">&quot;value2&quot;</span></span><br><span class="line">// 2) <span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure><h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set是string类型的无序集合。<br>set通过哈希表实现，所以添加，删除，查找的复杂度都是O(1)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sadd myset member1 member2</span><br><span class="line"></span><br><span class="line">smembers myset</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="zset-有序集合"><a href="#zset-有序集合" class="headerlink" title="zset 有序集合"></a>zset 有序集合</h2><p>与set一样是string类型的集合，且不允许重复成员。<br>不同的是每一个元素都会关联一个double类型的分数。redis通过分数来为集合中的成员从小到大来排序。<br>zset中的成员是唯一的，但分数（score）可以重复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member</span><br></pre></td></tr></table></figure><h1 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h1><p><a href="https://redis.io/commands">命令大全</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 是一个高性能的key-value数据库&lt;/p&gt;</summary>
    
    
    
    <category term="database" scheme="https://everbrez.github.io/categories/database/"/>
    
    
    <category term="database" scheme="https://everbrez.github.io/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>restful api</title>
    <link href="https://everbrez.github.io/2019-06-01-restful-api/"/>
    <id>https://everbrez.github.io/2019-06-01-restful-api/</id>
    <published>2019-06-01T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>REST 是 <code>REpresentational State Tranfer</code> 的缩写。</p><span id="more"></span><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://blog.florimond.dev/restful-api-design-13-best-practices-to-make-your-users-happy">restful-api-design-13-best-practices-to-make-your-users-happy</a></li><li><a href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design">api-design</a></li><li><a href="https://restfulapi.net/">restful api</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">restful api 最佳实践</a></li></ol><h1 id="关于HTTP的基础概念"><a href="#关于HTTP的基础概念" class="headerlink" title="关于HTTP的基础概念"></a>关于HTTP的基础概念</h1><ul><li>HTTP具有动词（方法），常用的有：GET、POST、PUT、DELETE、PATCH</li><li>REST是面向资源的（resource oriented），一个资源使用URL来表示，如：<code>/articles/</code></li><li>操作指令是由动词 + URL 来表示，如：<code>POST: /articles/</code> 可以用来表示创建新的文章</li><li>动词（HTTP METHOD）可以用来表示<code>CRUD (Create，Read，Update，Delete)</code>操作，如：</li></ul><table><thead><tr><th align="center">method</th><th align="center">crud</th></tr></thead><tbody><tr><td align="center">GET</td><td align="center">read</td></tr><tr><td align="center">POST</td><td align="center">create</td></tr><tr><td align="center">PUT/PATCH</td><td align="center">update</td></tr><tr><td align="center">DELETE</td><td align="center">delete</td></tr></tbody></table><ul><li>响应状态由响应code来表示，<code>1xx</code>表示信息，<code>2xx</code>表示成功，<code>3xx</code>表示重定向，<code>4xx</code>表示客户端错误，<code>5xx</code>表示服务端错误。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;REST 是 &lt;code&gt;REpresentational State Tranfer&lt;/code&gt; 的缩写。&lt;/p&gt;</summary>
    
    
    
    <category term="backend" scheme="https://everbrez.github.io/categories/backend/"/>
    
    
    <category term="backend" scheme="https://everbrez.github.io/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>SEO</title>
    <link href="https://everbrez.github.io/2019-05-30-SEO/"/>
    <id>https://everbrez.github.io/2019-05-30-SEO/</id>
    <published>2019-05-30T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>搜索优化</p><span id="more"></span><h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><ol><li>添加网站关键词</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词1,关键词2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="seo-tips">https://ahrefs.com/blog/zh/seo-tips/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;搜索优化&lt;/p&gt;</summary>
    
    
    
    <category term="performance" scheme="https://everbrez.github.io/categories/performance/"/>
    
    
    <category term="performance" scheme="https://everbrez.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>CSS variables</title>
    <link href="https://everbrez.github.io/2019-04-13-css-variables/"/>
    <id>https://everbrez.github.io/2019-04-13-css-variables/</id>
    <published>2019-04-13T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>一文带你了解CSS变量</p><span id="more"></span><h1 id="CSS变量能够为我们做什么？"><a href="#CSS变量能够为我们做什么？" class="headerlink" title="CSS变量能够为我们做什么？"></a>CSS变量能够为我们做什么？</h1><p>CSS变量一个最常用的场景就是使用在网站的主题上。</p><p>思考下面一个场景：假设我们有一个站点，里面的主题色是<code>tomato</code>，但是某一天我们收到了一个需求：用户可以切换网站两种不同的主题颜色。那么如果你是网站的开发者，你会怎么做？</p><p>一种简单的方法就是在css文件中预先写好这两套颜色的主题，然后根据用户的操作来决定那一套主题生效。</p><p>但是这里有一个问题：假设可以让用户随意切换主题颜色呢？显然将所有颜色都预设在css文件中是不现实的，这时候可能就需要使用到JavaScript了。但是颜色的代码分布在css中的不同地方，使用JavaScript操作起来显得非常地麻烦。</p><p>这时候就轮到CSS变量的登场了。</p><h1 id="说到CSS变量，怎么能够不提到它呢？"><a href="#说到CSS变量，怎么能够不提到它呢？" class="headerlink" title="说到CSS变量，怎么能够不提到它呢？"></a>说到CSS变量，怎么能够不提到它呢？</h1><p>说到CSS变量，我们就来提一下被称为“CSS有史以来的第一个变量”：<code>currentColor</code>。相信不少同学都有使用过<code>currentColor</code>的经验，那么为什么这个值就被称为“CSS有史以来的第一个变量”呢？为什么像<code>inherit</code>这种值就不被称为变量呢？它可是比<code>currentColor</code>更早出现呢…</p><blockquote><p>以下为个人见解，如有错误，请联系作者更改</p></blockquote><h2 id="currentColor"><a href="#currentColor" class="headerlink" title="currentColor"></a>currentColor</h2><p>先来介绍一下<code>currentColor</code>：<code>currentColor</code>的值是取自<code>color</code>的值。什么意思呢？看下面的栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: tomato;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid currentColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.example的标签显示出<code>tomato</code>颜色，这表明了currentColor取自当前的color值。</p><p>当当前的<code>color</code>没有设置的时候，currentColor会取什么颜色呢？事实上，currentColor会向上遍历，直到<code>:root</code>根类元素的color值。可以理解为<code>currentColor</code>为当前标签继承获得的<code>color</code>值。</p><p>可以看到，<code>currentColor</code>的取值依赖于<code>color</code>，当<code>color</code>改变的时候，<code>currentColor</code>随之改变。而且<code>currentColor</code>查找<code>color</code>与<code>JavaScript</code>中变量搜索作用域链比较类似，<code>currentColor</code>因为与变量相似的特性被认为是一个变量。</p><h2 id="inherit"><a href="#inherit" class="headerlink" title="inherit"></a>inherit</h2><p>那么inherit呢？使用了<code>inherit</code>表明要继承父类的样式属性，也会使子元素继承那些不会自动继承的属性。<br>… 未完待续</p><h1 id="CSS变量"><a href="#CSS变量" class="headerlink" title="CSS变量"></a>CSS变量</h1><p>讲了这么多，终于要进入正题了。下面看看CSS变量怎么使用</p><p>在JavaScript等语言中，变量往往需要一个声明步骤，CSS变量也不例外。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>CSS中，如果属性值前加两条中划线，代表这是一个自定义属性：<code>--&lt;example-property&gt;: &lt;value&gt;</code>，看一个栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  --<span class="selector-tag">main</span>-<span class="attribute">color</span>: tomato;</span><br><span class="line">  --second-<span class="attribute">color</span>: lightskyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了两种不同颜色的自定义属性，也就是这里说的CSS变量。</p><p>既然定义了变量，那么该如何使用？看下面的栗子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color, black);</span><br><span class="line">  <span class="comment">/* black 为 fallback 颜色，即当 --main-color 不生效（如找不到相应的声明）的时候，会使用 black 作为代替 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--second-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用了<code>var()</code>语法来读取变量。</p><h2 id="JavaScript操作"><a href="#JavaScript操作" class="headerlink" title="JavaScript操作"></a>JavaScript操作</h2><p>继续回归到上面的场景，如果需要让用户自定义网站的主题颜色，那么应该怎么做呢？</p><p>事实上，CSS变量可以使用JavaScript操作，所以改变一个CSS变量的值，就可以改变所有引用这个变量位置的值。大大减少了工作量。</p><p>下面看一个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取相应的 DOM 元素</span></span><br><span class="line"><span class="keyword">const</span> exampleElement = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.example&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> colorPicker = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.color-picker&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加事件处理</span></span><br><span class="line">colorPicker.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 获取用户选择的颜色</span></span><br><span class="line">  <span class="keyword">const</span> selectedColor = event.target.value</span><br><span class="line">  <span class="comment">// 改变变量的值</span></span><br><span class="line">  exampleElement.style.setProperty(<span class="string">&#x27;--main-color&#x27;</span>, selectedColor)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文介绍的CSS变量其实只是冰山一角，还有一些深入的知识比如作用域、与其他函数如<code>calc()</code>联用等等内容，有机会再详细介绍~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一文带你了解CSS变量&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/categories/JavaScript/"/>
    
    
    <category term="CSS" scheme="https://everbrez.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>React in depth</title>
    <link href="https://everbrez.github.io/2019-03-28-react-in-depth/"/>
    <id>https://everbrez.github.io/2019-03-28-react-in-depth/</id>
    <published>2019-03-28T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章记录学习React深层原理</p><span id="more"></span><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://medium.com/react-in-depth">react-in-depth</a></li><li><a href="https://engineering.musefind.com/our-best-practices-for-writing-react-components-dec3eb5c3fc8">Our Best Practices for Writing React Components</a></li><li><a href="https://blog.angularindepth.com/what-every-front-end-developer-should-know-about-change-detection-in-angular-and-react-508f83f58c6a">What every front-end developer should know about change detection in Angular and React</a></li><li><a href="https://medium.com/react-in-depth/practical-application-of-reverse-engineering-guidelines-and-principles-784c004bb657">Practical application of reverse-engineering guidelines and principles</a></li></ol><h1 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h1><blockquote><p><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p></blockquote><h1 id="React是如何更新的？"><a href="#React是如何更新的？" class="headerlink" title="React是如何更新的？"></a>React是如何更新的？</h1><blockquote><p><a href="https://medium.com/react-in-depth/in-depth-explanation-of-state-and-props-update-in-react-51ab94563311">In-depth explanation of state and props update in React</a></p></blockquote><h1 id="React的事件机制"><a href="#React的事件机制" class="headerlink" title="React的事件机制"></a>React的事件机制</h1><h1 id="diff-算法的本质"><a href="#diff-算法的本质" class="headerlink" title="diff 算法的本质"></a>diff 算法的本质</h1><blockquote><p><a href="https://blog.angularindepth.com/what-every-front-end-developer-should-know-about-change-detection-in-angular-and-react-508f83f58c6a">What every front-end developer should know about change detection in Angular and React</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章记录学习React深层原理&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript React" scheme="https://everbrez.github.io/tags/JavaScript-React/"/>
    
  </entry>
  
  <entry>
    <title>URL Encode</title>
    <link href="https://everbrez.github.io/2019-03-27-url-encode/"/>
    <id>https://everbrez.github.io/2019-03-27-url-encode/</id>
    <published>2019-03-27T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中，有两个API可以用来对URL进行编码：<code>encodeURL</code>以及<code>encodeURLComponent</code></p><span id="more"></span><h1 id="encodeURL"><a href="#encodeURL" class="headerlink" title="encodeURL"></a>encodeURL</h1><h1 id="encodeURLComponent"><a href="#encodeURLComponent" class="headerlink" title="encodeURLComponent"></a>encodeURLComponent</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;在JavaScript中，有两个API可以用来对URL进行编码：&lt;code&gt;encodeURL&lt;/code&gt;以及&lt;code&gt;encodeURLComponent&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript URL" scheme="https://everbrez.github.io/tags/JavaScript-URL/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="https://everbrez.github.io/2019-03-24-cookie/"/>
    <id>https://everbrez.github.io/2019-03-24-cookie/</id>
    <published>2019-03-24T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>一个HTTP cookie 是一个存储数据的方式，它是由服务端发送到客户端的。</p><p>浏览器会存储它，并会在下一次发起请求的时候携带cookie。（如果是命中了domain、path等字段）</p><span id="more"></span><blockquote><p>cookie是纯文本格式，不包含任何可执行的代码。</p></blockquote><h1 id="cookie-使用目的"><a href="#cookie-使用目的" class="headerlink" title="cookie 使用目的"></a>cookie 使用目的</h1><ol><li>session 管理</li><li>用户设置管理（Personalization）</li><li>跟踪用户行为（Tracking）</li></ol><h1 id="生成cookie"><a href="#生成cookie" class="headerlink" title="生成cookie"></a>生成cookie</h1><p>cookie是由服务端返回的响应头来设置的，以分号分隔：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>&lt;cookie-name&gt;=&lt;cookie-value&gt;</span><br></pre></td></tr></table></figure><h1 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h1><p>原始规范中明确指出只有三个字符必须进行编码：分号、逗号和空格，规范中还提到可以进行URL编码，但不是必须的。</p><p>对于<code>name=value</code>格式，通常对<code>name</code>和<code>value</code>分别进行编码，而不对等号<code>=</code>进行编码操作。</p><h1 id="支持选项"><a href="#支持选项" class="headerlink" title="支持选项"></a>支持选项</h1><blockquote><p>大小写不敏感</p></blockquote><ol><li>Expires 和 Max-Age</li><li>Secure：只能使用HTTPS请求，该选项<strong>只是一个标志而没有值</strong></li><li>HttpOnly：cookie不能使用JavaScript访问</li><li>Domain 和 Path</li><li>SameSite：两个可选值：strict 和 lax</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure><h2 id="Expires-amp-Max-Age"><a href="#Expires-amp-Max-Age" class="headerlink" title="Expires &amp; Max-Age"></a>Expires &amp; Max-Age</h2><p>紧跟cookie值后面的每个选项都以分号和空格分开。<code>Expires</code>和<code>Max-Age</code>指定了cookie何时不会再发送至服务器，随后浏览器将删除该cookie。（时间是根据系统时间来计算的）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>name=value; Expires=Wed, 27 Mar 2019 05:03:33 GMT</span><br></pre></td></tr></table></figure><p>在没有设置<code>expires</code>和<code>Max-Age</code>的情况下，cookie的生命周期仅限于当前会话中，关闭浏览器意味着这次会话的结束，所以会话cookie仅存在于浏览器打开状态下。</p><p>如果<code>expires</code>设置了过去的一个时间点，那么这个cookie会被立即删除。</p><p>如果<code>Max-Age</code>设置了0，这个cookie也会被立即删除。</p><h2 id="Domain-amp-Path"><a href="#Domain-amp-Path" class="headerlink" title="Domain &amp; Path"></a>Domain &amp; Path</h2><p><code>Domain</code>和<code>Path</code>字段指定了cookie的作用域：即cookie应该发送给哪些URL</p><p><code>Domain</code>标识符指定了哪些主机可以接收cookie。如果不指定，默认为当前主机（不包含子域名）<code>document.location</code>，如果指定了<code>Domain</code>，则一般包含子域名。</p><p><code>Path</code>指定了主机下什么路径可以接收cookie。子路径也会被匹配。</p><blockquote><p><code>Domain</code>只能设置为当前消息头主机名的一部分，同样<code>Path</code>设置的路径要存在于当前请求URL。不合法的 <code>Domain</code> 选择将直接被忽略。</p></blockquote><blockquote><p>需要注意的是，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。同时，如果设置<code>Path=/blog</code>也会匹配<code>/blogrool</code></p></blockquote><h2 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h2><p>默认情况下，在HTTPS链接上传输的cookie都会被自动添加上<code>secure</code>选项</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><p>如果需要改变cookie的值，需要发送给另外一个具有相同<code>name</code>、<code>domain</code>、<code>path</code>的<code>Set-Cookie</code>消息头，这将覆盖原来的cookie值</p><p>cookie标识：<code>name-domain-path-secure</code></p><p><code>Expires</code>和<code>Max-Age</code>不是标识符的一部分，所以需要修改cookie的值的时候不需要重新指定过期时间。</p><blockquote><p>如果修改了任一选项，则会新创建一个cookie。发送到服务器的cookie会根据<code>Path</code>来排序，<code>Path</code>越详细cookie越靠前。</p></blockquote><h2 id="自动删除"><a href="#自动删除" class="headerlink" title="自动删除"></a>自动删除</h2><p>cookie会被浏览器自动删除：</p><ol><li>会话cookie</li><li>持久化cookie过期</li><li>cookie数量达到上限，浏览器删除</li></ol><h2 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h2><p>有一些浏览器如ie会限制cookie的数量</p><p>发送给服务器的所有cookie最大值为4KB，所有超过限制的cookie都会被截断并且不会发送至服务器。</p><h2 id="SubCookies"><a href="#SubCookies" class="headerlink" title="SubCookies"></a>SubCookies</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>name=a=b&amp;c=d&amp;e=f</span><br></pre></td></tr></table></figure><p>在单个cookie中保存多个<code>name-value</code>键值对</p><h2 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h2><blockquote><p>不能通过 JavaScript 设置 <code>HttpOnly</code>选项，因为不能再通过 JavaScript 读取这些 cookie</p></blockquote><h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><ol><li><code>document.cookie</code></li><li><code>navigator.cookieEnabled</code></li></ol><blockquote><p>一旦 cookie 通过 JavaScript 设置后便不能提取它的选项，所以你将不能知道 <code>Domain</code>，<code>Path</code>，<code>Expires</code> 日期或 <code>Secure</code> 标记。</p></blockquote><p>使用<code>document.cookie</code>可以向使用<code>Set-Cookie</code>一样将cookie赋值即可，标识符一致的cookie会被修改</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.kancloud.cn/kancloud/http-cookies-explained/48317">cookie</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">http-cookies MDN</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个HTTP cookie 是一个存储数据的方式，它是由服务端发送到客户端的。&lt;/p&gt;
&lt;p&gt;浏览器会存储它，并会在下一次发起请求的时候携带cookie。（如果是命中了domain、path等字段）&lt;/p&gt;</summary>
    
    
    
    <category term="NetWork" scheme="https://everbrez.github.io/categories/NetWork/"/>
    
    
    <category term="HTTP cookie NetWork" scheme="https://everbrez.github.io/tags/HTTP-cookie-NetWork/"/>
    
  </entry>
  
  <entry>
    <title>inode</title>
    <link href="https://everbrez.github.io/2019-03-24-inode/"/>
    <id>https://everbrez.github.io/2019-03-24-inode/</id>
    <published>2019-03-24T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>inode</p><span id="more"></span><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">inode</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;inode&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="https://everbrez.github.io/categories/OS/"/>
    
    
    <category term="OS" scheme="https://everbrez.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>unit test</title>
    <link href="https://everbrez.github.io/2019-03-25-unit-test/"/>
    <id>https://everbrez.github.io/2019-03-25-unit-test/</id>
    <published>2019-03-24T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>单元测试</p><span id="more"></span><h1 id="单元测试覆盖率度量方式"><a href="#单元测试覆盖率度量方式" class="headerlink" title="单元测试覆盖率度量方式"></a>单元测试覆盖率度量方式</h1><ol><li>语句覆盖/行覆盖</li><li>判定覆盖</li><li>条件覆盖</li><li>路径覆盖</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;单元测试&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="https://everbrez.github.io/categories/test/"/>
    
    
    <category term="test" scheme="https://everbrez.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>drag</title>
    <link href="https://everbrez.github.io/2019-03-23-drag-api/"/>
    <id>https://everbrez.github.io/2019-03-23-drag-api/</id>
    <published>2019-03-23T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5拖拽</p><span id="more"></span><h1 id="Drag"><a href="#Drag" class="headerlink" title="Drag"></a>Drag</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTML5拖拽&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://everbrez.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Continuous Integration</title>
    <link href="https://everbrez.github.io/2019-03-20-continuous-integration/"/>
    <id>https://everbrez.github.io/2019-03-20-continuous-integration/</id>
    <published>2019-03-20T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>CI 是一种软件开发实践，它是指频繁地将代码集成到仓库，然后通过自动构建验证每一个集成</p><span id="more"></span><p>好处有：</p><ol><li>可以快速发现错误。每完成一点就更新，集成到主干，可以快速发现错误</li><li>防止分支大幅偏离主干。如果不是经常继承，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li></ol><p>目的：让产品快速迭代，同时还能够保持高质量。<br>核心措施：代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p><p>工作原理<br><img src="/assets/images/ci.png" alt="CI"></p><ol><li>开发者向代码仓库提交代码，commit</li><li>代码仓库会触发CIbuild，向CI server发出信号</li><li>CI server根据设定的任务来运行测试</li><li>部署，artifacts</li></ol><p><a href="https://circleci.com/blog/deploying-documentation-to-github-pages-with-continuous-integration/">circleci-deploy-to-GitHub-Pages</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CI 是一种软件开发实践，它是指频繁地将代码集成到仓库，然后通过自动构建验证每一个集成&lt;/p&gt;</summary>
    
    
    
    <category term="test" scheme="https://everbrez.github.io/categories/test/"/>
    
    
    <category term="test CI" scheme="https://everbrez.github.io/tags/test-CI/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://everbrez.github.io/2019-03-20-docker/"/>
    <id>https://everbrez.github.io/2019-03-20-docker/</id>
    <published>2019-03-20T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发最麻烦的事请就是环境配置。而Docker就是为了解决这个问题而诞生的。</p><span id="more"></span><p>在Docker之前，虚拟机是带环境安装的一种解决方案。但是这个方案有几个缺点：</p><ol><li>占用资源多</li><li>冗余步骤多</li><li>启动慢</li></ol><h1 id="Linux-容器"><a href="#Linux-容器" class="headerlink" title="Linux 容器"></a>Linux 容器</h1><p>Linux容器不是模拟一个完整的操作系统，而是对进程进行隔离。对于容器里的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离<br>优点：</p><ol><li>启动快</li><li>资源占用少</li><li>体积小</li></ol><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口。<br>Docker将应用程序与该程序的依赖打包在一个文件里面，运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</p><p>用途：</p><ol><li>提供一次性的环境（持续继承、本地测试他人软件）</li><li>提供弹性的云服务。（Docker容器可以随开随关，很适合动态扩容和缩容）</li><li>组建微服务架构。通过多个容器，一台机器可以跑多个服务</li></ol><h2 id="image文件"><a href="#image文件" class="headerlink" title="image文件"></a>image文件</h2><p>Docker将应用程序及其依赖，打包在image文件里面。只有通过这个文件，才能生成Docker容器。image 文件可以看作是容器的模板，Docker根据image文件生成容器的实例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;软件开发最麻烦的事请就是环境配置。而Docker就是为了解决这个问题而诞生的。&lt;/p&gt;</summary>
    
    
    
    <category term="back-end" scheme="https://everbrez.github.io/categories/back-end/"/>
    
    
    <category term="back-end docker" scheme="https://everbrez.github.io/tags/back-end-docker/"/>
    
  </entry>
  
  <entry>
    <title>HTML Cheat Sheet</title>
    <link href="https://everbrez.github.io/2019-03-23-html-sheet/"/>
    <id>https://everbrez.github.io/2019-03-23-html-sheet/</id>
    <published>2019-03-20T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个面向beginner的HTML CHEAT SHEET </p><span id="more"></span><p><img src="/assets/images/HTML-CHEAT-SHEET.jpg" alt="HTML-CHEAT-SHEET"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个面向beginner的HTML CHEAT SHEET &lt;/p&gt;</summary>
    
    
    
    <category term="HTML" scheme="https://everbrez.github.io/categories/HTML/"/>
    
    
    <category term="HTML" scheme="https://everbrez.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>interview summary</title>
    <link href="https://everbrez.github.io/2019-03-18-my-interview-summary/"/>
    <id>https://everbrez.github.io/2019-03-18-my-interview-summary/</id>
    <published>2019-03-18T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是记录自己以及朋友在春招面试遇到的问题，以提醒自己还有什么没有掌握。</p><span id="more"></span><h1 id="腾讯一面"><a href="#腾讯一面" class="headerlink" title="腾讯一面"></a>腾讯一面</h1><ol><li>typeof [] object</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.foo(); <span class="comment">// &#x27;bar&#x27;</span></span><br><span class="line">(bar.foo)(); <span class="comment">// &#x27;bar&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line">(c = bar.foo)(); <span class="comment">// &#x27;global&#x27;</span></span><br><span class="line">(c, bar.foo)(); <span class="comment">// &#x27;global&#x27;</span></span><br><span class="line">bar.foo.call(<span class="built_in">this</span>); <span class="comment">// &#x27;global&#x27;</span></span><br><span class="line">bar.foo.call(<span class="built_in">window</span>); <span class="comment">// &#x27;global&#x27;</span></span><br></pre></td></tr></table></figure><ol><li>HTTP状态码</li><li>网络缓存和浏览器缓存</li><li>数组去重</li><li>输出n -&gt; m范围的随机整数</li><li>正则：第一个为大写首字母，其他是3-13位字母数字和下划线</li><li>MVVM</li><li>简述客户端优化</li><li>原生使用ajax请求</li><li>实现两边定宽，中间自适应布局</li><li>写出display的值</li><li>内存泄漏</li></ol><h1 id="阿里评测"><a href="#阿里评测" class="headerlink" title="阿里评测"></a>阿里评测</h1><ol><li>工作室负责任务，然后问了一下后台</li><li>讲到了统计工具，问了一下后端数据怎么拿</li><li>问了数据怎么处理</li><li>问了在项目中React干了什么</li><li>跨域</li><li>var let const</li><li>深复制，浅复制</li><li>工具 vscode</li><li>git push了一个错误，怎么回退, git revert可以撤销commit，同时生成一个记录</li><li>webpack？</li><li>非React时代项目</li><li>熟悉什么算法</li></ol><h1 id="腾讯二面（LMH）"><a href="#腾讯二面（LMH）" class="headerlink" title="腾讯二面（LMH）"></a>腾讯二面（LMH）</h1><ol><li>node</li><li>小程序</li><li>项目</li><li>做过哪些优化</li><li>要用 HTTP2.0 要怎么做</li></ol><h1 id="网易一面"><a href="#网易一面" class="headerlink" title="网易一面"></a>网易一面</h1><ol><li>travis CI 与 cicle CI 的区别，gitlab CI？一般可以干什么，可以配置什么</li></ol><ul><li><a href="https://hackernoon.com/continuous-integration-circleci-vs-travis-ci-vs-jenkins-41a1c2bd95f5">区别</a></li><li>cicle CI：可以使用ssh本地调试，YAML config比较轻量，无需专用服务器（但允许在私有云运行），缓存需要的安装，需要很少的配置，开箱即用</li><li>travis CI: （也有 YAML config， cloud base， 支持docker，）可以选择在Linux或者 Mac OSX运行，更多语言，支持构建矩阵（使用不同环境和语言）</li></ul><ol start="2"><li>了解sass什么？继承与mixin区别</li><li>你了解的前端工程化</li></ol><ul><li>规范，eslint/stylelint</li><li>流程，增强开发进度管理和控制git</li><li>模块化</li><li>组件化</li><li>单元测试</li><li>自动化工具</li></ul><ol start="4"><li>如果要重构一个新闻页面，你会用到什么H5新标签。figure为什么需要，直接img标签不行吗</li><li>简述一下HTTP缓存，如果要获得最新的文件，为什么不使用query而是改变文件名? 后端怎么知道链接有没有缓存</li><li>了解渲染对优化性能有什么作用？defer与async的区别，使用场景</li><li>你了解的自适应网站是什么</li><li>任务循环？</li></ol><h1 id="腾讯一面（ZCX）"><a href="#腾讯一面（ZCX）" class="headerlink" title="腾讯一面（ZCX）"></a>腾讯一面（ZCX）</h1><ol><li>React router的原理</li><li>跨域原理</li><li>webpack怎么编译？原理</li><li>求中位数？– 堆 – 改进的快排 – 排序</li><li>webpack的public path是干什么的？</li><li>vue 的 node 模块</li><li>animation参数</li></ol><h1 id="网易一面（FZL）"><a href="#网易一面（FZL）" class="headerlink" title="网易一面（FZL）"></a>网易一面（FZL）</h1><ol><li>node流</li><li>CSS3的新属性</li><li>算法：中位数</li><li>算法：100层楼，2颗弹珠</li></ol><h1 id="腾讯一面（二）"><a href="#腾讯一面（二）" class="headerlink" title="腾讯一面（二）"></a>腾讯一面（二）</h1><ol><li>animation 与 transition区别？</li><li>React事件</li><li>map与reduce方法</li><li>redux</li><li>实现布局：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">---------  -----------</span><br><span class="line">|  图   |  |  title  |</span><br><span class="line">|  片   |  |----------</span><br><span class="line">|       |  | content |</span><br><span class="line">---------  -----------</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><ol start="6"><li>你对前端的理解</li><li>position</li><li>谈谈项目</li><li>项目？你觉得为什么要生成随机类名呢</li><li>自己的项目？</li><li>之前面过一次，你觉得为什么没过</li></ol><h1 id="腾讯一面（三）2019-03-23"><a href="#腾讯一面（三）2019-03-23" class="headerlink" title="腾讯一面（三）2019-03-23"></a>腾讯一面（三）2019-03-23</h1><ol><li>自我介绍</li><li>介绍一下项目经历（就加入工作室之后做了什么项目）</li><li>介绍一下继承，讲了Object.create()，组合继承，ES6继承</li><li>new操作符发生了什么</li><li>跨域，JSONP原理</li><li>ES6</li><li>箭头函数</li><li>一个对话框，垂直居中，水平居中（其中内容还是可以点击），讲了fixed，margin auto</li><li>缓存和HTTP状态码304，HTTP头怎么设置的</li><li>输入URL到渲染—&gt; TCP挥手</li><li>redux的数据流向</li><li>事件委托</li><li>React的事件机制</li><li>规划，投了什么，怎么学习，相比科班的优势</li><li>还有什么问题？</li></ol><h1 id="字节跳动一面-2019-03-23"><a href="#字节跳动一面-2019-03-23" class="headerlink" title="字节跳动一面 2019-03-23"></a>字节跳动一面 2019-03-23</h1><ol><li>自我介绍</li><li>进程和线程</li><li>HTTPS</li><li>写一道算法题：给一个无重复的数组arr，要求找到n个数，其和为m，找到这n个数的组合</li><li>重绘和回流</li><li>cookie、sessionStorage和localStorage</li><li>缓存</li><li>你觉得在webpack中css可以require进来，那么css打包了之后是什么样子的。在网页上它又是怎么运行的？</li><li>有自己优化过吗？客户端优化</li><li>一道简单关于this的题目</li></ol><h1 id="字节跳动二面-2019-03-23"><a href="#字节跳动二面-2019-03-23" class="headerlink" title="字节跳动二面 2019-03-23"></a>字节跳动二面 2019-03-23</h1><ol><li>自我介绍</li><li>介绍项目，项目中遇到什么难点</li><li>思考：一般搜索之后的值会有提示，假如搜索了123，那么输入1的时候就会有123提示出来，如果要按照时间的顺序来排序，应该怎么实现。如果输入13之后123也需要出现在提示中，又应该怎么做？</li><li>算法：假设定义一个绝对大值n，其在数组中的出现次数大于数组length的一半。找出这样的数。比如[1,1,1,5,1,1]，1出现了5次，大于数组长度的一般3，所以绝对大值为1</li><li>你觉得为什么React中setState是异步的？</li><li>在React15和16版本中，你觉得React最大的更新是什么？</li><li>怎么实现一个事件订阅发布机制</li></ol><h1 id="字节跳动三面-2019-03-23"><a href="#字节跳动三面-2019-03-23" class="headerlink" title="字节跳动三面 2019-03-23"></a>字节跳动三面 2019-03-23</h1><ol><li>自我介绍</li><li>React中的HOC与render props的区别</li><li>如果要讲一个props从祖先组件传递到嵌套较深的子组件，有什么方法？讲了Context和Redux，问还有吗？没有想到</li><li>一道题目：[‘apple’, ‘pears’, ‘apple’]问有多少个单词，在不引入新的变量的情况下（后面给了提示：使用reduce）</li><li>题目：判断下面代码的运行情况，并说明理由</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><ol start="6"><li>React中的render component与controlled component有什么区别（没听清楚是否这两个组件）</li><li>Etag怎么生成？</li><li>Etag为什么要跟last-modified一起使用？</li><li>题目：实现一个throttle函数</li><li>组件化和模块化的区别</li><li>单元测试中一般怎么衡量覆盖度？只回答了if/else分支</li><li>模拟一个instanceof的过程</li></ol><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><blockquote><p>from network</p></blockquote><ol><li>阅读这篇<a href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/">文章</a></li><li>解释下这个 <a href="https://codesandbox.io/s/jj0mk6y683">bug</a> 的产生原因。</li><li>比较这个  <a href="https://codesandbox.io/s/jj0mk6y683">bug</a> 的代码和 <a href="https://jsbin.com/jipivovasa/1/edit?js,console">https://jsbin.com/jipivovasa/1/edit?js,console</a><br>以及 <a href="https://jsbin.com/macasotini/1/edit?js,console">https://jsbin.com/macasotini/1/edit?js,console</a><br>解释两段代码输出的 <code>count</code> 值不一样的原因。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章是记录自己以及朋友在春招面试遇到的问题，以提醒自己还有什么没有掌握。&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="https://everbrez.github.io/categories/interview/"/>
    
    
    <category term="interview" scheme="https://everbrez.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>CSS in depth</title>
    <link href="https://everbrez.github.io/2019-03-17-css/"/>
    <id>https://everbrez.github.io/2019-03-17-css/</id>
    <published>2019-03-17T00:00:00.000Z</published>
    <updated>2021-05-22T12:26:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>css</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;css&lt;/p&gt;</summary>
    
    
    
    <category term="CSS" scheme="https://everbrez.github.io/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://everbrez.github.io/tags/CSS/"/>
    
  </entry>
  
</feed>
